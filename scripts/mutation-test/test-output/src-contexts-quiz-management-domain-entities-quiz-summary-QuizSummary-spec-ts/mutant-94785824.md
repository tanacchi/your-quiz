# Mutant 94785824 Report

**File**: src/contexts/quiz-management/domain/entities/quiz-summary/QuizSummary.spec.ts
**Mutator**: BlockStatement
**Original ID**: 3785
**Stable ID**: 94785824
**Location**: L522:33–L647:4

## Diff

```diff
Index: src/contexts/quiz-management/domain/entities/quiz-summary/QuizSummary.spec.ts
===================================================================
--- src/contexts/quiz-management/domain/entities/quiz-summary/QuizSummary.spec.ts	original
+++ src/contexts/quiz-management/domain/entities/quiz-summary/QuizSummary.spec.ts	mutated #3785
@@ -518,135 +518,10 @@
       });
     });
   });
 
-  describe("Draft Class", () => {
-    let draft: InstanceType<typeof QuizSummary.Draft>;
+  describe("Draft Class", () => {});
 
-    beforeEach(() => {
-      draft = new QuizSummary.Draft();
-    });
-
-    it("should initialize with empty state", () => {
-      expect(draft.state).toEqual({});
-    });
-
-    describe("Field operations", () => {
-      it.each([
-        ["question", "Draft question"],
-        ["answerType", "single_choice"],
-        ["explanation", "Draft explanation"],
-        ["creatorId", "draft-creator"],
-        ["solutionId", "draft-solution"],
-      ])("should set and get %s field", (field, value) => {
-        draft.update(field as keyof typeof validQuizData, value);
-        expect(draft.get(field as keyof typeof validQuizData)).toBe(value);
-      });
-    });
-
-    it("should set multiple values at once", () => {
-      const updates = {
-        question: "Draft question",
-        answerType: "single_choice",
-        explanation: "Draft explanation",
-      } as const;
-
-      draft.with(updates);
-
-      expect(draft.get("question")).toBe("Draft question");
-      expect(draft.get("answerType")).toBe("single_choice");
-      expect(draft.get("explanation")).toBe("Draft explanation");
-    });
-
-    describe("Validation error handling", () => {
-      it.each([
-        ["empty question", { question: "" }, "question"],
-        ["invalid answerType", { answerType: "invalid" }, "answerType"],
-        ["empty creatorId", { creatorId: "" }, "creatorId"],
-        ["empty solutionId", { solutionId: "" }, "solutionId"],
-        ["invalid createdAt", { createdAt: "invalid-date" }, "createdAt"],
-      ])(
-        "should validate and store errors for %s",
-        (_desc, invalidData, errorField) => {
-          Object.entries(invalidData).forEach(([key, value]) => {
-            draft.update(key as keyof typeof validQuizData, value);
-          });
-
-          expect(draft.hasErrors()).toBe(true);
-          const fieldErrors = draft.getErrors(errorField);
-          expect(fieldErrors.length).toBeGreaterThan(0);
-        },
-      );
-
-      it("should clear errors when data becomes valid", () => {
-        // First set invalid data
-        draft.update("question", "");
-        expect(draft.hasErrors()).toBe(true);
-
-        // Then fix the data
-        draft.update("question", "Valid question");
-        draft.with(validQuizData as Record<string, unknown>);
-        expect(draft.hasErrors()).toBe(false);
-      });
-    });
-
-    describe("Commit operations", () => {
-      it("should commit to QuizSummary when valid", () => {
-        draft.with(validQuizData as Record<string, unknown>);
-
-        const result = draft.commit();
-
-        const quiz = result._unsafeUnwrap({ withStackTrace: true });
-        expect(quiz.get("question")).toBe("What is TypeScript?");
-      });
-
-      it.each([
-        ["empty question", { question: "" }],
-        ["invalid answerType", { answerType: "invalid" }],
-        ["missing creatorId", { creatorId: undefined }],
-        ["missing solutionId", { solutionId: undefined }],
-      ])("should fail to commit with %s", (_desc, invalidData) => {
-        draft.with({
-          ...(validQuizData as Record<string, unknown>),
-          ...invalidData,
-        } as Parameters<typeof draft.with>[0]);
-
-        const result = draft.commit();
-
-        const error = result._unsafeUnwrapErr({ withStackTrace: true });
-        expect(error).toBeDefined();
-        expect(error.issues.length).toBeGreaterThan(0);
-      });
-    });
-
-    describe("Error management", () => {
-      it("should clear errors manually", () => {
-        draft.update("question", ""); // creates error
-        expect(draft.hasErrors()).toBe(true);
-
-        draft.clearErrors();
-        expect(draft.hasErrors()).toBe(false);
-      });
-
-      it.each([
-        ["existing field", "question", ""],
-        ["non-existent field", "nonexistent", ""],
-      ])("should get errors for %s", (_desc, field, invalidValue) => {
-        if (field === "question") {
-          draft.update("question", invalidValue);
-        }
-
-        const fieldErrors = draft.getErrors(field);
-
-        if (field === "question") {
-          expect(fieldErrors.length).toBeGreaterThan(0);
-        } else {
-          expect(fieldErrors).toEqual([]);
-        }
-      });
-    });
-  });
-
   describe("Type Safety", () => {
     it("should enforce return type constraints", () => {
       const result = QuizSummary.from(validQuizData);
       const quiz = result._unsafeUnwrap({ withStackTrace: true });
```

## Hint

ミューテータ "BlockStatement" による置換。

## Instruction

このサバイブ・ミューテーションを失敗させる最小テストを設計してください。
