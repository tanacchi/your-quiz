# ADR: 技術選定・システム構成に関する意思決定記録

## 文書目的

本ADRは、クイズアプリケーション開発における主要技術・アーキテクチャ・インフラ選定の意思決定過程と理由を記録し、将来の変更・レビュー時の根拠とする。

---

## 1. フロントエンド技術選定

### 選択肢

- Next.js 15
- React Router v7

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| Next.js 15 | SSR/SSG標準, PWA対応容易, TypeScript最適化, Vercel統合 | 設定複雑, バンドルサイズ大 | ○ |
| React Router v7 | 軽量, SPA特化, 設定シンプル | SSR未対応, SEO弱い | △ |

### 決定

**Next.js 15**を採用。PWA・SEO・TypeScript最適化・Vercel統合が現状要件に最適。

---

## 2. UI・スタイリング技術選定

### 選択肢

- Tailwind CSS
- styled-components

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| Tailwind CSS | Utility-First, カスタマイズ容易, TypeScript対応, モバイル最適化 | HTML肥大化, 学習コスト | ○ |
| styled-components | CSS-in-JS, 動的スタイル | バンドルサイズ大, SSR複雑 | △ |

### 決定

**Tailwind CSS**を採用。アニメーション・レスポンシブ対応が容易。

---

## 3. 状態管理ライブラリ選定

### 選択肢

- Zustand
- Redux Toolkit
- Jotai
- Recoil
- MobX

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| Zustand | 軽量, TypeScript最適, 設定シンプル | エコシステム小, 複雑状態管理制限 | ○ |
| Redux Toolkit | 成熟, DevTools充実 | 設定複雑, 過剰機能 | △ |
| Jotai | 軽量, 原子設計 | エコシステム小 | △ |
| Recoil | Facebook製, グラフ構造 | 学習コスト | △ |
| MobX | 柔軟, リアクティブ | 学習コスト | △ |

### 決定

**Zustand**を採用。シンプルな状態管理要件に最適。

---

## 4. バックエンドAPIフレームワーク選定

### 選択肢

- Hono
- Nest.js

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| Hono | 超軽量, TypeScript設計, エッジ対応, 100ms要件対応 | エコシステム小, 実績少 | ○ |
| Nest.js | 成熟, DI, エコシステム豊富 | 重い, 設定複雑 | △ |

### 決定

**Hono**を採用。API応答速度・TypeScript最適化・シンプルなAPI要件に最適。

---

## 5. データベース選定

### 選択肢

- D1 (Cloudflare)
- SQLite
- PostgreSQL
- Neon PostgreSQL
- PlanetScale MySQL
- Railway PostgreSQL

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| D1 (Cloudflare) | エッジ配置, SQLite互換, 無料枠大 | 機能制限, 新サービス | ○ |
| SQLite | 軽量, 設定不要 | 同時書き込み制限 | ○ |
| PostgreSQL | 高機能, 拡張性高 | 設定複雑, 運用コスト高 | ○ |
| Neon PostgreSQL | Serverless, 自動スケール | 新しい, 制限あり | △ |
| PlanetScale MySQL | ブランチング, 企業実績 | 高コスト, MySQL制約 | △ |
| Railway PostgreSQL | 統合管理, 自動バックアップ | 単一AZ, 制限あり | △ |

### 決定

**D1 (Cloudflare, SQLiteベース)**を採用。エッジ配置・無料枠・移行容易性を重視。

---

## 6. ORM選定

### 選択肢

- Drizzle ORM
- Prisma
- TypeORM
- Kysely

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| Drizzle ORM | TypeScript特化, 軽量, 型安全 | 新しい, エコシステム小 | ○ |
| Prisma | 成熟, スキーマ管理 | 重い, クエリ制限 | ○ |
| TypeORM | デコレータ, 複雑クエリ対応 | 設定複雑, パフォーマンス課題 | △ |
| Kysely | 型安全, 軽量 | ORM機能なし | △ |

### 決定

**Drizzle ORM**を採用。TypeScript特化・軽量・SQL透明性を重視。

---

## 7. フロントエンドホスティング選定

### 選択肢

- Vercel
- Netlify
- Cloudflare Pages

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| Vercel | Next.js最適化, 自動デプロイ, エッジ配信 | ベンダーロック, コスト上昇 | ○ |
| Netlify | Git統合, CDN | 遅延問題, ビルド制限 | △ |
| Cloudflare Pages | 高速配信, 無制限帯域 | 機能限定, 新しい | ○ |

### 決定

**Vercel**を採用。Next.js最適化・PWA対応・高速配信。

---

## 8. APIホスティング選定

### 選択肢

- Cloudflare Workers
- Railway
- Render
- Fly.io
- Supabase Functions
- PlanetScale + Vercel Functions

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| Cloudflare Workers | 超高速, エッジ実行, 無制限リクエスト | 実行時間制限, Node.js制限 | ○ |
| Railway | DB統合, Git連携 | 新しい, 実績少 | ○ |
| Render | Docker対応, 実績豊富 | 無料枠制限厳しい | △ |
| Fly.io | エッジ配信, 低レイテンシ | 設定複雑, 学習コスト高 | ○ |
| Supabase Functions | PostgreSQL統合, TypeScript | Serverless制限 | △ |
| PlanetScale + Vercel Functions | MySQL互換, エッジ | コスト高, 複雑構成 | △ |

### 決定

**Cloudflare Workers + D1 Database**を採用。Hono最適化・100ms要件・無料枠・運用シンプル。

---

## 9. エラーハンドリングライブラリ選定

### 選択肢

- neverthrow
- fp-ts
- 独自実装

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| neverthrow | 型安全, Result型, TypeScript最適 | 学習曲線急, 既存コード移行コスト | ○ |
| fp-ts | 高機能, 関数型エコシステム | 学習コスト極高, 可読性低下 | × |
| 独自実装 | 軽量, 完全制御 | 保守コスト, バグリスク | △ |

### 決定

**neverthrow**を採用。型安全なエラーハンドリング統一。

---

## 10. テストフレームワーク選定

### 選択肢

- Vitest
- Jest

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| Vitest | Vite統合, 高速, TypeScript最適 | 新しい技術, エコシステム発展途上 | ○ |
| Jest | 成熟, 機能豊富 | 設定複雑, 実行速度 | △ |

### 決定

**Vitest**を採用。Vite統合・高速・TypeScript型安全。

---

## 11. 型定義・コード生成ツール選定

### 選択肢

- openapi-typescript
- 手動定義

### 比較・評価

| 選択肢 | メリット | デメリット | 判定 |
|--------|----------|------------|------|
| openapi-typescript | OpenAPI→TypeScript, 型安全, 自動生成 | 生成ファイル大, OpenAPI依存 | ○ |
| 手動定義 | 柔軟性, カスタマイズ自由 | 保守負荷, 型漏れリスク | × |

### 決定

**openapi-typescript**を採用。型安全性・保守性・自動化重視。

---

## 12. システムアーキテクチャパターン選定

### 選択肢

- モジュラーモノリス
- モノリス
- マイクロサービス

### 比較・評価

| 選択肢 | メリット | デメリット | 評価 |
|--------|----------|------------|------|
| モジュラーモノリス | 単一デプロイ, モジュール境界, 拡張性 | 境界規律維持コスト, 単一障害点 | ★★★ |
| モノリス | 開発初期高速, デプロイ容易 | 拡張性制限, 境界曖昧化 | ★★ |
| マイクロサービス | 独立デプロイ, 障害分離 | 複雑性, 運用コスト高 | ★ |

### 決定

**モジュラーモノリス**を採用。小規模チーム・拡張性・運用負荷軽減。

---

## 13. アプリケーションアーキテクチャパターン選定

### 選択肢

- ヘキサゴナル
- レイヤード
- クリーン

### 比較・評価

| 選択肢 | メリット | デメリット | 評価 |
|--------|----------|------------|------|
| ヘキサゴナル | ドメイン分離, テスタビリティ, 外部依存注入 | 初期設計コスト, レイヤー間マッピング | ★★★ |
| レイヤード | 理解容易, 実装単純 | ドメイン散在リスク, 技術依存強 | ★★ |
| クリーン | 依存関係逆転, 高抽象度 | 過度な抽象化, 実装複雑 | ★ |

### 決定

**ヘキサゴナルアーキテクチャ**を採用。ドメイン独立性・テスタビリティ・拡張性重視。

---

## 14. システム境界・外部連携方針

### 選択肢

- 直接アクセス（ブラウザストレージ）
- REST API（認証）
- Message Queue（通知）

### 比較・評価

| 連携先 | 連携方式 | 理由 | データ形式 | エラーハンドリング |
|--------|----------|------|------------|-------------------|
| ブラウザストレージ | Direct Access | オフライン対応・履歴保存 | JSON | バックアップ+同期 |
| 認証システム | REST API | リアルタイム認証要求 | JSON | リトライ+フォールバック |
| 通知システム | Message Queue | 非同期・高可用性 | JSON | Dead Letter Queue |

### 決定

現状は**Direct Access**（ブラウザストレージ）を採用。将来はREST API/Message Queue連携を段階的に導入。

---

## 参考

- 技術選定・比較表: system-context.md, tech-selection.md
- 各意思決定の詳細理由は該当ドキュメント参照
