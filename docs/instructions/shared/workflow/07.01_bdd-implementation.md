# BDDテスト実装

## 目的

- ビジネス関係者と開発チームが共通理解を持ち、ユーザー価値に焦点を当てたソフトウェア開発を実現するため、E2Eおよびドメイン結合シナリオをPactumJS形式で記述し、実行可能な仕様として機能するBDDテストを実装する

### BDDが目指す世界観

- **共通理解**: 全ステークホルダーが同じ言葉で仕様を理解し、手戻りを最小化
- **生きたドキュメント**: テストが実行可能な仕様書として機能し、自動的に同期
- **ビジネス価値重視**: ユーザー行動に焦点を当て、技術詳細より成果を優先
- **継続的対話**: 早期検証と小単位修正によるフィードバックループ

## 遵守事項

- **全てのBDDテストは表形式のデータ駆動テスト（Examples配列）で書く**
- **PactumJS Chainable DSL形式でのシナリオ記述を行う**
- **実行可能な仕様として機能するBDDテストを実装する**
- ユビキタス言語を定義し、ステークホルダー間の共通理解を構築する
- 技術的詳細ではなくビジネス価値に焦点を当てる
- OpenAPIスキーマとの自動同期によりスペックとコードの乖離を防ぐ

## BDDテスト実装の手順

### 1. ユビキタス言語定義

#### 1.1 用語集作成

- `glossary/` ディレクトリ配下に `ubiquitous-language.md` ファイルを作成する
- プロジェクト固有のドメイン用語を定義する

#### 1.2 用語の合意形成

以下の手順で関係者間の用語統一を行う：

1. **ドメインエキスパートとの用語抽出セッション**
   - ビジネス側のキーパーソンと用語の意味を確認
   - 同義語や類義語の整理
   - 曖昧な表現の明確化

2. **開発チーム内での用語共有**
   - 技術実装との対応関係を明確化
   - コード内の命名規則との整合性確保

3. **用語集の構造化**

```markdown
# ユビキタス言語

## ドメイン用語
- **ユーザー**: システムを利用する個人または組織
- **アカウント**: ユーザーの認証情報とプロフィール情報
- **セッション**: ログイン状態を管理する一時的な接続

## アクション動詞
- **登録する**: 新規ユーザーがアカウントを作成する行為
- **認証する**: ユーザーが正当性を証明する行為
- **承認する**: システムがアクセス権限を付与する行為

## 状態表現
- **アクティブ**: 利用可能な状態
- **非アクティブ**: 一時的に利用停止中の状態
- **削除済み**: 論理削除された状態

## 判定基準
- **成功**: 処理が期待通りに完了した状態
- **失敗**: エラーまたは例外により処理が中断した状態
- **保留**: 外部承認待ちで処理が一時停止している状態
```

#### 1.3 用語集の維持管理

- 新機能開発時の用語追加・更新
- 定期的なレビューと整合性確認
- 非推奨用語の管理と移行計画

### 2. PactumJSシナリオ記述

#### 2.1 シナリオファイル作成

- `tests/` ディレクトリ配下に `.spec.ts` ファイルを作成する
- ファイル名は機能名を反映した分かりやすい名前にする（例：`user-registration.spec.ts`）

#### 2.2 PactumJS Chainable DSLでの記述

以下の構造でシナリオを記述する：

```typescript
import { spec } from 'pactum';
import { testData } from '../fixtures/user-data';

describe('User Registration - ユーザー登録', () => {
  
  beforeAll(() => {
    // 共通の前提条件
  });

  describe('正常系シナリオ', () => {
    testData.validUsers.forEach((userData, index) => {
      it(`有効なユーザーデータで登録成功: ${userData.description}`, async () => {
        await spec()
          .post('/users')
          .withJson(userData.input)
          .expectStatus(201)
          .expectJsonMatchSnapshot();
      });
    });
  });
  
  describe('異常系シナリオ', () => {
    testData.invalidUsers.forEach((userData, index) => {
      it(`無効なデータで登録失敗: ${userData.description}`, async () => {
        await spec()
          .post('/users')
          .withJson(userData.input)
          .expectStatus(400)
          .expectJsonLike({ error: userData.expectedError });
      });
    });
  });
});
```

**データ駆動テスト記述必須理由**:

- テストデータのバリエーションを配列で網羅的にカバーする
- Edge Case（境界値、異常系）を表形式で漏れなく検証する
- 同一シナリオの複数パターンをforEach()で効率的に管理する

```typescript
// fixtures/user-data.ts
export const testData = {
  validUsers: [
    { description: "通常メールアドレス", input: { email: "user@example.com" }, expected: {...} },
    { description: "長いメールアドレス", input: { email: "very.long.email@example.com" }, expected: {...} }
  ],
  invalidUsers: [
    { description: "メール形式不正", input: { email: "invalid" }, expectedError: "INVALID_EMAIL" }
  ]
};
```

#### 2.3 シナリオ記述の原則

- **describe()**: 機能・コンテキストの説明（ユビキタス言語使用）
- **beforeAll/beforeEach**: システムの初期状態や前提条件を実装
- **it()**: 具体的なテストケース名称（ビジネス価値重視）
- **spec().method()**: APIアクション実行
- **expectStatus/expectJson**: 期待される結果や状態変化を検証
- 各テストは具体的で検証可能な内容にする
- ビジネス価値に基づいたシナリオを優先する

### 3. テストヘルパー・ユーティリティ実装

#### 3.1 ヘルパーファイル作成

- `helpers/` または `utils/` ディレクトリ配下にファイルを作成
- 機能ごとにファイルを分割する（例：`user-api-helpers.ts`）

#### 3.2 ヘルパー関数の実装

```typescript
// API呼び出しヘルパー例
export class UserAPIHelper {
  static async clearUsers() {
    // データベースの初期化
    await spec().delete('/test/users/all').expectStatus(200);
  }

  static async createUser(userData: CreateUserRequest) {
    return await spec()
      .post('/users')
      .withJson(userData)
      .expectStatus(201)
      .returns('body');
  }

  static async expectUserRegistrationSuccess(response: any) {
    expect(response.status).toBe(201);
    expect(response.body).toHaveProperty('id');
    expect(response.body).toHaveProperty('email');
  }
}
```

#### 3.3 ヘルパー関数の原則

- 各ヘルパーは単一責任の原則に従う
- 再利用可能なAPI呼び出しパターンをクラス化する
- テストデータは外部ファイルまたは Fixture として管理する
- 非同期処理は適切に `async/await` を使用する
- PactumJS Chainable DSLを活用した統一的なAPI呼び出し

### 4. テスト環境セットアップ

#### 4.1 Jest Hook関数の実装

```typescript
// beforeAll/beforeEach: テストスイート実行前の処理
describe('Quiz API Tests', () => {
  beforeAll(async () => {
    // グローバル設定
    await TestDatabase.migrate();
    await TestApplication.start();
  });

  beforeEach(async () => {
    // 各テスト前のデータクリーンアップ
    await TestDatabase.cleanup();
  });

  afterAll(async () => {
    // テストスイート完了後の処理
    await TestApplication.stop();
  });
});
```

#### 4.2 PactumJS設定とベースURL設定

```typescript
// jest.setup.ts - テスト実行コンテキストの定義
import { handler, settings } from 'pactum';

beforeAll(() => {
  // PactumJS基本設定
  settings.setBaseUrl('http://localhost:8787');
  settings.setDefaultTimeout(5000);
  
  // OpenAPI Swagger Coverage 設定
  handler.addSpecHandler('swagger', (ctx) => {
    // OpenAPI自動検証・カバレッジ収集
  });
});
```

### 5. テストデータ管理

#### 5.1 Fixture ファイル作成

- `fixtures/` ディレクトリ配下にテストデータを配置
- JSON形式またはYAML形式でデータを管理

```json
// fixtures/users.json
{
  "validUser": {
    "email": "user@example.com",
    "password": "SecurePassword123"
  },
  "invalidUser": {
    "email": "invalid-email",
    "password": "weak"
  }
}
```

#### 5.2 データベース状態管理

- 各シナリオで独立したデータ状態を保証する
- シナリオ間でのデータ汚染を防ぐ
- テスト用データベースを使用する

### 6. エラーハンドリング

#### 6.1 失敗時の診断情報収集

```typescript
// Jest afterEach hook for error handling
afterEach(async () => {
  if (expect.getState().assertionCalls > 0) {
    // テスト失敗時のログ出力
    console.log('Test context:', {
      testName: expect.getState().currentTestName,
      timestamp: new Date().toISOString()
    });

    // API レスポンス詳細をログ出力
    if (global.lastPactumResponse) {
      console.log('Last API Response:', global.lastPactumResponse);
    }
  }
});
```

#### 6.2 適切なエラーメッセージとOpenAPI検証

- PactumJSの.expectJson()で詳細なアサーションメッセージを記述
- OpenAPI Swaggerカバレッジで自動的にスキーマ不整合を検出
- デバッグに必要な情報をPactumJSが自動でログ出力

### 7. 並列実行対応

#### 7.1 テスト分離

- 各シナリオが独立して実行できるよう設計
- 共有リソースへの同時アクセスを避ける
- データベースやファイルシステムの競合状態を防ぐ

#### 7.2 リソース管理

- テストポート番号の動的割り当て
- 一意なテストデータベース名の使用
- 並列実行時のタイムアウト設定調整

## 完了判定基準

### 必須要件

- [x] **ユビキタス言語定義**: 用語集が作成され、ドメインエキスパートと合意されている
- [x] **表形式データ駆動テスト**: 全シナリオがforEach()で記述され、Examples配列を含む
- [x] **PactumJS形式遵守**: 全シナリオがspec()チェーン構造で記述されている
- [x] **ヘルパー実装**: API Helperクラスが実装され、テストがコンパイル・実行可能になっている
- [x] **Red状態確認**: BDDテスト実行時に全シナリオが期待通りRedで失敗している
- [x] **OpenAPI連携**: SwaggerCoverageによる自動スキーマ検証が動作している
- [x] **単一責任原則**: 各ヘルパーが単一責任の原則に従って実装されている

### 成果物

1. **ユビキタス言語用語集** (`glossary/ubiquitous-language.md`)
2. **BDDシナリオファイル群** (`tests/*.spec.ts`)
3. **テストヘルパー・ユーティリティファイル群** (`helpers/*.ts`)
4. **テストフィクスチャファイル群** (`fixtures/*.ts`)
5. **BDD実行レポート** (全Red確認済み + OpenAPIカバレッジ)

## 完了後の必須アクション

1. **直ちに**ユーザーに「BDDテストスイート」のレビューを依頼する
2. **ADR作成判断**: BDDフレームワーク、テスト戦略について、ADRでの記録をユーザーに提案する
3. **次工程の判断**をユーザーに委ねる：
   - 通常フロー：「スケルトン実装」に進む
   - 戻りフロー：シナリオ過不足による仕様調整で前工程に戻る
4. ユーザーの明示的な承認を得てから指定された工程に進む

- テストデータが適切に管理されていること
- Hook関数によるセットアップ・クリーンアップが実装されていること
- エラーハンドリングが適切に実装されていること
- 並列実行に対応した設計になっていること
- Markdownのlintルールに従っていない記述が少ないこと

## 完了後

- アウトプットを全てリストアップし、ユーザーからのレビューを受ける
