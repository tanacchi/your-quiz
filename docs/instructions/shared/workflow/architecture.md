# アーキテクチャ策定・技術選定

## 目的

- 仕様整理で明確化された要件に基づき、システム全体のアーキテクチャ方針と具体的な技術スタックを決定し、後続のドメイン設計・API設計・DB設計工程に対する技術的制約と設計指針を提供するため、アーキテクチャパターンの選定根拠・技術選定・トレードオフを明示した包括的な技術設計書を作成する

## 遵守事項

- アーキテクチャパターンの選定理由と技術的トレードオフを明確に記述する
- **全ての技術選定は必ず表形式で比較検討を行う**
- **アーキテクチャ設計で決定された方針との整合性を確認する**
- 抽象度を保ち、後続工程への制約と指針を提供する
- 図表を用いてアーキテクチャパターンを視覚的に表現する
- 代替案との比較検討を通じて選定の妥当性を示す
- プロジェクト要件・チーム技術力・保守性を総合的に判断する
- ライブラリのバージョン・ライセンス・メンテナンス状況を確認する

## 重要な制約事項

### 適切な抽象度の維持

**このフェーズでは以下は含めてはならない**:

- 具体的なAPIエンドポイント設計（例：GET /api/users/{id}、POST /api/quizzes）
- 詳細なSQLクエリやDB操作（例：SELECT * FROM users WHERE id = ?）
- 具体的なUI実装詳細（例：特定のCSS設定、コンポーネント実装）
- データスキーマの詳細設計（例：テーブル定義、フィールド型指定）
- リクエスト/レスポンス形式の詳細（例：JSON構造の具体的な定義、TypeScript interface定義）
- 具体的なHTTPメソッドとパスの組み合わせ表
- APIレスポンス時間の具体的な数値表（例：「50ms」「100ms」等）
- 詳細なエラーコード体系（例：「VALIDATION_ERROR」「TOKEN_EXPIRED」等）

**特に注意が必要なファイル**:
- `communication-patterns.md`: 通信方式の方針のみ記述し、具体的なエンドポイント一覧表は含めない
- `data-architecture.md`: データ管理の方針のみ記述し、具体的なスキーマ定義は含めない

**このフェーズで含むべき内容**:

- 概念レベルでのデータフロー（例：「クイズデータ取得」「回答結果送信」）
- アーキテクチャパターンの選定（例：モジュラーモノリス、ヘキサゴナル）
- 技術スタックの選定（例：React、Node.js、PostgreSQL）
- 通信方式の決定（例：REST API、WebSocket）
- 非機能要件の対応方針（例：パフォーマンス、セキュリティ）

## 技術選定の必須成果物形式

### 基本比較検討表

**重要**: 個別技術（DB種別、フレームワーク等）を選定する前に、必ずアーキテクチャ全体での役割・位置づけを確認すること。

#### 全ての技術選定は以下の表形式で整理すること

```markdown
| 選択肢 | メリット | デメリット | 適用場面 | コスト | 学習曲線 | チーム適合性 | 判定 |
|--------|----------|------------|----------|--------|----------|------------|------|
| 選択肢A | 利点1<br>利点2 | 欠点1<br>欠点2 | 場面1<br>場面2 | 高/中/低 | 急/緩 | 高/中/低 | ○/△/× |
| 選択肢B | 利点1<br>利点2 | 欠点1<br>欠点2 | 場面1<br>場面2 | 高/中/低 | 急/緩 | 高/中/低 | ○/△/× |
```

### DB選定表の例

```markdown
| データベース | メリット | デメリット | 適用場面 | 運用コスト | 学習曲線 | チーム適合性 | 判定 |
|-------------|----------|------------|----------|------------|----------|------------|------|
| MySQL | ・実績豊富<br>・運用ノウハウ蓄積<br>・ツール充実 | ・スケール制限<br>・JSON処理弱い<br>・レプリケーション複雑 | ・中規模まで<br>・リレーショナル中心<br>・OLTP | 低 | 緩 | 高 | ○ |
| PostgreSQL | ・高機能<br>・拡張性高い<br>・ACID厳密 | ・学習コスト高<br>・設定複雑<br>・メモリ消費大 | ・複雑なクエリ<br>・大規模データ<br>・地理空間 | 中 | 急 | 中 | △ |
| MongoDB | ・スキーマ柔軟<br>・水平スケール<br>・開発高速 | ・整合性制約弱い<br>・複雑なクエリ苦手<br>・運用ノウハウ不足 | ・ドキュメント指向<br>・プロトタイプ<br>・ログデータ | 中 | 中 | 低 | × |
```

### マイクロサービス vs モノリス比較表

```markdown
| アーキテクチャ | メリット | デメリット | 適用場面 | チーム規模 | 技術的複雑さ | 運用負荷 | 判定 |
|---------------|----------|------------|----------|------------|--------------|----------|------|
| モノリス | ・開発初期高速<br>・デプロイ単純<br>・トランザクション容易<br>・デバッグ容易 | ・大規模時保守困難<br>・技術スタック固定<br>・部分スケール不可<br>・チーム衝突 | ・小〜中規模<br>・単一チーム<br>・MVP段階<br>・シンプルドメイン | 1-10名 | 低 | 低 | ○ |
| マイクロサービス | ・独立デプロイ<br>・技術選択自由<br>・障害分離<br>・チーム独立性 | ・分散システム複雑性<br>・データ整合性課題<br>・運用コスト高<br>・ネットワーク遅延 | ・大規模<br>・複数チーム<br>・ドメイン境界明確<br>・高可用性要求 | 20名以上 | 高 | 高 | × |
| モジュラーモノリス | ・モノリスの単純さ<br>・モジュール分離<br>・段階的移行可能<br>・境界明確化 | ・境界維持要努力<br>・完全分離は困難<br>・将来分割時作業大 | ・中規模<br>・将来分割予定<br>・成長期 | 5-15名 | 中 | 中 | △ |
```

## アウトプット出力先

### 基本方針

アーキテクチャ設計と技術選定文書は、プロジェクトドキュメント体系として整理し、`docs/project/architecture/` ディレクトリに集約して後続工程からの参照を容易にする。

### 出力先ディレクトリ構造

```text
docs/project/architecture/
├── system-overview.md              # システム全体俯瞰・方針
├── patterns/                       # アーキテクチャパターン
│   ├── architecture-decision.md    # アーキテクチャ判断・選定理由
│   ├── communication-patterns.md   # 通信パターン・プロトコル
│   └── data-flow-design.md        # データフロー設計
├── technology/                     # 技術選定
│   ├── tech-stack-overview.md     # 技術スタック概要・方針
│   ├── libraries/                  # ライブラリ選定
│   │   ├── error-handling.md      # エラーハンドリング（neverthrow等）
│   │   ├── orm.md                 # ORM選定
│   │   ├── validation.md          # バリデーション
│   │   ├── testing.md             # テストフレームワーク
│   │   └── ui-framework.md        # UIフレームワーク
│   ├── infrastructure/             # インフラ技術選定
│   │   ├── database.md            # データベース選定
│   │   ├── deployment.md          # デプロイメント
│   │   └── monitoring.md          # 監視・ログ
│   └── comparison-tables/          # 比較検討表
│       └── tech-comparison-matrix.md # 技術比較マトリクス
└── constraints/                    # 技術制約・ガイドライン
    ├── technical-constraints.md    # 技術制約事項
    └── development-guidelines.md   # 開発ガイドライン
```

### ファイル命名規則

- **全体俯瞰文書**: `system-overview.md`
- **アーキテクチャ文書**: `{パターン名}-{内容}.md`
- **技術選定文書**: `{技術分野}-selection.md`
- **比較検討表**: `{カテゴリ}-comparison.md`

### 各成果物の保存場所

- **システム全体文書**: `architecture/` 直下に配置
- **パターン固有文書**: `patterns/` 配下に分類
- **技術選定文書**: `technology/` 配下に分類
- **制約・ガイドライン**: `constraints/` 配下に分類

## 技術選定の手順

### 1. アーキテクチャ方針との整合性確認

#### 1.1 前提条件の確認

- アーキテクチャ設計で決定されたアーキテクチャパターンの確認
- 通信方式（同期/非同期）、データストア方針の確認
- 非機能要件（パフォーマンス、セキュリティ、可用性）の確認

#### 1.2 制約条件の明確化

- チーム技術力レベルの評価
- 学習コスト許容範囲の設定
- 運用・保守体制の考慮
- ライセンス制約の確認

### 2. 必須技術カテゴリの選定

#### 2.1 エラーハンドリング（neverthrow等）

**選定必須理由**: TypeScript環境での関数型エラーハンドリング統一のため

| ライブラリ | メリット | デメリット | 適用場面 | 学習コスト | メンテナンス性 | パフォーマンス | 判定 |
|------------|----------|------------|----------|------------|---------------|--------------|------|
| **neverthrow** | ・Result型提供<br>・型安全なエラー処理<br>・関数型プログラミング対応<br>・TypeScript最適化 | ・学習曲線が急<br>・既存コード移行コスト<br>・チーム教育必要 | ・API結果処理<br>・ビジネスロジック<br>・外部連携 | 中 | 高 | 高 | ○ |
| fp-ts | ・高機能<br>・関数型エコシステム充実<br>・数学的厳密性 | ・学習コストが極めて高い<br>・オーバーエンジニアリング<br>・可読性低下リスク | ・関数型プログラミング中心<br>・複雑なデータ変換 | 高 | 高 | 中 | × |
| 独自実装 | ・プロジェクト特化<br>・軽量<br>・完全制御 | ・テスト負荷<br>・保守コスト<br>・バグリスク | ・シンプルな要件<br>・特殊制約 | 低 | 低 | 高 | △ |

#### 2.2 ORM/クエリビルダー

**選定必須理由**: データベースアクセスの統一とタイプセーフなクエリ実行のため

| ORM/ツール | メリット | デメリット | 適用場面 | 型安全性 | パフォーマンス | 学習コスト | 判定 |
|------------|----------|------------|----------|----------|---------------|------------|------|
| **Prisma** | ・強力な型生成<br>・マイグレーション機能<br>・開発体験が良好<br>・インクリメンタル採用可能 | ・新しい技術<br>・複雑クエリ制限<br>・生成ファイルが大きい<br>・ベンダーロックイン | ・TypeScript中心<br>・RAD開発<br>・プロトタイプ | 高 | 中 | 低 | ○ |
| TypeORM | ・デコレータベース<br>・Active Record対応<br>・エコシステムが成熟<br>・複雑クエリ対応 | ・設定が複雑<br>・実行時型チェック<br>・パフォーマンス課題<br>・メンテナンス性 | ・エンタープライズ<br>・既存システム移行<br>・複雑ドメイン | 中 | 低 | 中 | △ |
| Kysely | ・クエリビルダー<br>・型安全<br>・軽量<br>・SQL制御可能 | ・ORM機能なし<br>・マイグレーション別途<br>・学習コスト<br>・ボイラープレート | ・パフォーマンス重視<br>・SQL熟練者<br>・細かい制御 | 高 | 高 | 高 | × |

#### 2.3 バリデーションライブラリ

**選定必須理由**: API入力値検証とTypeScript型システムとの統合のため

| ライブラリ | メリット | デメリット | 適用場面 | 型推論 | パフォーマンス | エラーメッセージ | 判定 |
|------------|----------|------------|----------|--------|---------------|-----------------|------|
| **zod** | ・TypeScript First<br>・優秀な型推論<br>・カスタムバリデーション<br>・エコシステム充実 | ・ランタイムオーバーヘッド<br>・複雑スキーマで型推論遅延<br>・学習コスト | ・API入力検証<br>・設定ファイル<br>・フォーム検証 | 高 | 中 | 高 | ○ |
| yup | ・成熟ライブラリ<br>・豊富な機能<br>・Formikとの親和性<br>・学習リソース多 | ・TypeScript対応弱<br>・型推論限定的<br>・設定複雑 | ・従来型開発<br>・JavaScript中心<br>・フォーム中心 | 低 | 高 | 中 | × |
| joi | ・高機能<br>・豊富な検証ルール<br>・企業採用実績<br>・安定性 | ・TypeScript対応なし<br>・型安全性皆無<br>・学習コスト高 | ・Node.js専用<br>・既存システム<br>・複雑検証 | 無 | 高 | 高 | × |

#### 2.4 HTTPクライアント

**選定必須理由**: 外部API連携とエラーハンドリング統一のため

| クライアント | メリット | デメリット | 適用場面 | 型安全性 | エラーハンドリング | 設定柔軟性 | 判定 |
|-------------|----------|------------|----------|----------|------------------|------------|------|
| **axios** | ・豊富な機能<br>・エコシステム成熟<br>・インターセプター<br>・ブラウザ/Node両対応 | ・Bundle size大<br>・設定複雑<br>・TypeScript対応弱 | ・複雑API連携<br>・認証処理<br>・エラーハンドリング | 低 | 中 | 高 | ○ |
| fetch (native) | ・標準API<br>・軽量<br>・Promise対応<br>・追加依存なし | ・機能限定<br>・ブラウザ差異<br>・設定繁雑<br>・エラーハンドリング弱 | ・シンプル通信<br>・軽量アプリ<br>・モダンブラウザ限定 | 無 | 低 | 低 | △ |
| ky | ・軽量<br>・TypeScript最適化<br>・モダンAPI<br>・Promise/async最適化 | ・エコシステム小<br>・学習リソース少<br>・企業採用実績少 | ・TypeScript重視<br>・軽量アプリ<br>・モダン開発 | 中 | 中 | 中 | × |

### 3. 開発・テスト環境ツール

#### 3.1 テストフレームワーク

| フレームワーク | メリット | デメリット | 適用場面 | 実行速度 | TypeScript対応 | 設定容易さ | 判定 |
|---------------|----------|------------|----------|----------|---------------|------------|------|
| **Vitest** | ・Vite統合<br>・高速実行<br>・TypeScript最適<br>・Jest互換API | ・新しい技術<br>・エコシステム発展途上<br>・学習リソース限定 | ・Viteプロジェクト<br>・モダンテスト<br>・高速開発 | 高 | 高 | 高 | ○ |
| Jest | ・成熟エコシステム<br>・豊富な機能<br>・学習リソース多<br>・企業採用実績 | ・設定複雑<br>・実行速度<br>・ESM対応課題 | ・従来型開発<br>・安定性重視<br>・大規模テスト | 中 | 中 | 中 | △ |

#### 3.2 型定義・コード生成

| ツール | メリット | デメリット | 適用場面 | 型安全性 | 保守性 | 学習コスト | 判定 |
|--------|----------|------------|----------|----------|--------|------------|------|
| **openapi-typescript** | ・OpenAPI→TypeScript<br>・自動生成<br>・型安全なAPI呼び出し<br>・フロントエンド統合 | ・生成ファイル大<br>・カスタマイズ制限<br>・OpenAPI依存 | ・API型定義<br>・フロント/バック統合<br>・TypeSpec連携 | 高 | 中 | 低 | ○ |

## 技術選定結果サマリ

### 最終選定技術スタック（例）

| カテゴリ | 選定技術 | バージョン | 選定理由 | 代替案 |
|----------|----------|------------|----------|--------|
| エラーハンドリング | neverthrow | ^6.0.0 | TypeScript最適化・型安全性 | fp-ts, 独自実装 |
| ORM | Prisma | ^5.0.0 | 開発効率・型安全性・マイグレーション | TypeORM, Kysely |
| バリデーション | zod | ^3.22.0 | TypeScript統合・型推論 | yup, joi |
| HTTPクライアント | axios | ^1.6.0 | 成熟度・機能性・安定性 | fetch, ky |
| テストフレームワーク | Vitest | ^1.0.0 | 高速・TypeScript対応 | Jest |
| 型生成 | openapi-typescript | ^6.7.0 | API型安全性・自動化 | 手動型定義 |

**注意**: 上記の選定結果はあくまで一例です。プロジェクトごとに要件や制約が異なるため、必ず独自の比較検討を行い、最適な技術を選定してください。

## 全体技術設計の手順

### 1. システムアーキテクチャパターン選定

#### 1.1 アーキテクチャスタイル決定

##### モノリス vs マイクロサービス vs モジュラーモノリス

各アーキテクチャ決定について以下の構造で記述する：

```markdown
## [アーキテクチャ要素名]

### 選定結果
**採用**: [選定されたパターン/技術]

### 判断基準
- **チーム規模**: [開発チーム・運用チームの規模と技術力]
- **ビジネス要件**: [変更頻度、機能間の結合度、独立デプロイ必要性]
- **非機能要件**: [スケーラビリティ、可用性、パフォーマンス要求]
- **技術制約**: [既存システム、インフラ制約、技術スタック]
- **組織制約**: [予算、スケジュール、コンプライアンス要件]

### 比較検討
| 選択肢 | メリット | デメリット | 適用可能性 | 評価 |
|--------|----------|------------|------------|------|
| モノリス | 開発初期の生産性高、デプロイ単純 | スケール限界、技術スタック固定 | 小〜中規模 | ★★★ |
| マイクロサービス | 独立スケール、技術多様性 | 運用複雑、分散システム課題 | 大規模・複数チーム | ★★ |
| **モジュラーモノリス** | **モノリスの簡単さ+分離** | **後のマイクロ化要検討** | **中規模・成長期** | **★★★** |

### 選定理由
1. **主要理由**: [最も重要な選定根拠]
2. **副次理由**: [補強する根拠]
3. **将来性**: [成長・変化への対応性]

### トレードオフ
**得られるもの**:
- [選定により獲得する価値]
- [解決される課題]

**失うもの/リスク**:
- [選定により失う選択肢]
- [発生するリスクと対策]

### 後続工程への影響
- **DDD設計**: [ドメイン境界、コンテキスト分離への制約]
- **API設計**: [通信方式、インターフェース設計への制約]
- **DB設計**: [データストア選択、分散設計への制約]
- **技術選定**: [フレームワーク、ライブラリ選択への制約]
```

##### アプリケーションアーキテクチャパターン選定

- **レイヤードアーキテクチャ**: 従来の階層型設計
- **ヘキサゴナルアーキテクチャ**: ポート&アダプターパターン
- **クリーンアーキテクチャ**: 依存関係逆転による疎結合設計
- **オニオンアーキテクチャ**: ドメイン中心の同心円設計

#### 1.2 システムコンテキスト設計

##### 外部システム連携方針

```markdown
### 外部システム連携パターン

| 連携先 | 連携方式 | 理由 | データ形式 | エラーハンドリング |
|--------|----------|------|------------|-------------------|
| 認証システム | REST API | リアルタイム認証要求 | JSON | リトライ+フォールバック |
| 決済システム | REST API | トランザクション整合性 | JSON | 2フェーズコミット |
| 通知システム | Message Queue | 非同期・高可用性 | JSON | Dead Letter Queue |
```

##### システム境界定義

- **内部システム**: 自組織で開発・運用するシステム範囲
- **外部システム**: 連携が必要な他システム・サービス
- **境界インターフェース**: システム間の通信仕様

### 2. 通信・統合パターン設計

#### 2.1 同期通信 vs 非同期通信の選定

##### 通信パターン適用指針

```markdown
### 通信方式選定マトリクス

| ユースケース | 推奨方式 | 理由 | 実装パターン |
|-------------|----------|------|-------------|
| ユーザー認証 | 同期（REST） | リアルタイム応答必須 | Request-Response |
| データ検索・表示 | 同期（REST） | ユーザー待機可能 | Request-Response |
| バッチ処理 | 非同期（Queue） | 時間がかかる処理 | Fire-and-Forget |
| 通知配信 | 非同期（Pub/Sub） | 複数システム連携 | Event-Driven |
| データ同期 | 非同期（Event） | 結果整合性許容 | Event Sourcing |
```

#### 2.2 API Gateway・Service Mesh適用判断

##### API Gateway適用判断

- **単一エントリーポイント**: クライアントからの全API呼び出しを集約
- **横断的関心事**: 認証、ログ、レート制限、モニタリング
- **適用条件**: マイクロサービス、複数API、横断機能必要

##### Service Mesh適用判断

- **サービス間通信制御**: 内部サービス間の通信管理
- **適用条件**: マイクロサービス多数、複雑なサービス間通信
- **トレードオフ**: 運用複雑さ vs 通信制御の統一

### 3. データアーキテクチャ方針

#### 3.1 データストア戦略

##### データストア選定マトリクス

```markdown
### データストア選定指針

| データ特性 | 推奨ストア | 理由 | 適用例 |
|-----------|-----------|------|--------|
| 構造化・ACID必要 | RDBMS | トランザクション保証 | ユーザー情報、決済 |
| 大量・高速読み取り | NoSQL（Document） | 水平スケール、柔軟スキーマ | コンテンツ、ログ |
| 高速アクセス | Cache（Redis） | メモリベース高速化 | セッション、一時データ |
| 時系列データ | Time Series DB | 時系列最適化 | メトリクス、IoTデータ |
| 全文検索 | Search Engine | 高度な検索機能 | 商品検索、ドキュメント |
```

#### 3.2 データ一貫性戦略

##### ACID vs BASE選択指針

- **ACID（強一貫性）**: 金融・決済・在庫管理等、データ整合性が絶対必要
- **BASE（結果整合性）**: ソーシャル・コンテンツ等、多少の遅延許容可能
- **ハイブリッド**: ドメインごとに一貫性要件を使い分け

##### 分散トランザクション戦略

- **2フェーズコミット**: 強一貫性必要、パフォーマンス許容
- **Sagaパターン**: 長時間トランザクション、補償処理可能
- **Event Sourcing**: イベント駆動、監査証跡必要

#### 3.3 CQRS・Event Sourcing適用判断

##### CQRS（Command Query Responsibility Segregation）

```markdown
### CQRS適用判断基準

**適用推奨条件**:
- 読み取りクエリと更新処理のパフォーマンス要件が大きく異なる
- 複雑なレポート・分析クエリが必要
- 読み取り頻度が更新頻度より圧倒的に高い

**適用非推奨条件**:
- CRUD操作が主体で複雑性が低い
- チームの分散システム経験が少ない
- データ整合性の複雑さを管理できない
```

### 4. 非機能要件対応方針

#### 4.1 スケーラビリティ戦略

##### 水平・垂直スケーリング選定

```markdown
### スケーリング戦略マトリクス

| 要求特性 | 推奨戦略 | 理由 | 実装方式 |
|----------|----------|------|----------|
| CPU集約的 | 垂直スケール | 単一インスタンス性能向上 | スペックアップ |
| I/O集約的 | 水平スケール | 並列処理で負荷分散 | ロードバランサ |
| 状態なし処理 | 水平スケール | 簡単にインスタンス追加可能 | オートスケール |
| 状態あり処理 | 垂直スケール→分散 | 状態管理の複雑さ考慮 | シャーディング |
```

#### 4.2 可用性・耐障害性設計

##### 冗長化戦略

- **Active-Active**: 複数インスタンスが同時稼働、負荷分散
- **Active-Standby**: メインが稼働、障害時にスタンバイに切り替え
- **Multi-AZ**: 複数のアベイラビリティゾーンに分散配置

##### 障害対応方針

- **Circuit Breaker**: 外部システム障害時の連鎖障害防止
- **Bulkhead**: 障害影響範囲の局所化
- **Timeout**: 無限待機防止

#### 4.3 セキュリティアーキテクチャ方針

##### 多層防御戦略

```markdown
### セキュリティ層設計

| 層 | 対策内容 | 実装方式 |
|----|----------|----------|
| ネットワーク層 | 不正アクセス防止 | Firewall、VPN |
| アプリケーション層 | 認証・認可 | JWT、OAuth2.0 |
| データ層 | 暗号化 | 保存時暗号化、転送時TLS |
| 監視層 | 異常検知 | ログ監視、侵入検知 |
```

##### ゼロトラスト原則適用

- **最小権限の原則**: 必要最小限の権限のみ付与
- **継続的検証**: アクセスの都度認証・認可確認
- **境界信頼の排除**: 内部ネットワークも信頼しない前提

### 5. パフォーマンス設計方針

#### 5.1 レスポンス時間要件

```markdown
### パフォーマンス目標設定

| 操作種別 | 目標応答時間 | 測定条件 | 対策方針 |
|----------|-------------|----------|----------|
| 画面表示 | < 2秒 | 95%tile | CDN、キャッシュ |
| API呼び出し | < 500ms | 95%tile | インデックス、最適化 |
| バッチ処理 | < 30分 | 夜間実行 | 並列処理、分割 |
| 検索処理 | < 1秒 | 平均 | 検索エンジン、インデックス |
```

#### 5.2 キャッシュ戦略

- **Browser Cache**: 静的リソースのクライアントキャッシュ
- **CDN**: 地理的分散による高速配信
- **Application Cache**: アプリケーション層でのデータキャッシュ
- **Database Cache**: クエリ結果キャッシュ

### 6. 図表作成指針

#### 6.1 Mermaid記法によるアーキテクチャ図作成

**重要**: アーキテクチャ策定工程では**概念レベル**の図のみ作成し、具体的なドメインエンティティ名・値オブジェクト名・ドメインサービス名は使用しない。これらの詳細はDDD設計工程で決定される。

##### システムコンテキスト図テンプレート

```mermaid
graph TB
    User[ユーザー] --> Web[Webアプリケーション]
    Web --> API[APIゲートウェイ]
    API --> App[アプリケーションサービス]
    App --> DB[(データベース)]
    App --> Ext[外部システム]

    subgraph "システム境界"
        API
        App
        DB
    end
```

##### データフロー図テンプレート

```mermaid
sequenceDiagram
    participant U as ユーザー
    participant W as Webアプリ
    participant A as APIサーバー
    participant D as データベース

    U->>W: リクエスト
    W->>A: API呼び出し
    A->>D: データ取得
    D-->>A: データ返却
    A-->>W: レスポンス
    W-->>U: 画面表示
```

#### 6.2 C4モデル準拠のアーキテクチャ表現

##### Level 1: System Context

- システムとユーザー、外部システムの関係
- システム境界の明確化

##### Level 2: Container

- システム内のアプリケーション・データストア構成
- 通信方式の表現

##### Level 3: Component

- 各コンテナ内のコンポーネント構成
- 責務分離の表現

### 7. アーキテクチャ決定記録（ADR）管理

アーキテクチャに関する重要な決定は、アーキテクチャ決定記録（ADR）として体系的に記録する。ADRの詳細な作成方法・管理方針については、`adr-management.md` を参照すること。

#### 7.1 ADR連携のポイント

- **全体技術設計での決定**: システムアーキテクチャパターン、通信方式、データアーキテクチャ方針等の重要決定をADRとして記録
- **トレードオフの明示**: 本工程で検討した代替案とその選定理由をADRで詳細化
- **後続工程への制約**: ADRで記録された決定が後続工程に与える制約を明確化

## 完了判定基準

### 基本要件

- `architecture/` ディレクトリ配下に役割ベースの適切な構造でファイルが作成されていること
- システム全体俯瞰（system-overview.md）が作成されていること
- 選定したアーキテクチャパターンがMermaid図表で図示されていること
- 技術的トレードオフと理由が箇条書きで明示されていること
- システムアーキテクチャスタイル（モノリス/マイクロサービス等）の選定が完了していること
- 通信パターン（同期/非同期）の選定指針が明確になっていること
- データアーキテクチャ方針（RDBMS/NoSQL/Cache等）が定義されていること
- 非機能要件（スケーラビリティ・可用性・セキュリティ）への対応方針が明示されていること
- アーキテクチャ決定記録（ADR）との連携方針が明確になっていること
- 各選定について代替案との比較検討が表形式で整理されていること
- 後続工程（DDD設計・API設計・DB設計・技術選定）への制約・指針が明確になっていること

### 抽象度チェック項目

**以下が含まれていないことを確認**:

- [ ] 具体的なAPIエンドポイント（/api/users、GET /quizzes等）
- [ ] 詳細なSQLクエリやDB操作文
- [ ] データスキーマの詳細設計（テーブル定義、カラム型等）
- [ ] 具体的なJSON構造やリクエスト/レスポンス形式
- [ ] UI実装の詳細（CSS設定、具体的なコンポーネント設計等）
- [ ] HTTPメソッドとパスの具体的な組み合わせ表
- [ ] APIレスポンス時間の具体的な数値（例：「50ms」「100ms」）
- [ ] TypeScript interface の具体的な定義
- [ ] 詳細なエラーコード体系（例：「VALIDATION_ERROR」）
- [ ] 具体的なドメインエンティティ名・値オブジェクト名・ドメインサービス名（これらはDDD設計工程で決定）

**特に communication-patterns.md のチェック項目**:

- [ ] エンドポイント一覧表が含まれていない
- [ ] 具体的なAPIパス（/api/quizzes/{id} 等）が含まれていない  
- [ ] TypeScript interface定義が含まれていない
- [ ] 通信方式の方針のみが記述されている

**特に hexagonal-architecture.md のチェック項目**:

- [ ] 具体的なドメインエンティティ名（Quiz Entity等）が含まれていない
- [ ] 具体的な値オブジェクト名（Quiz Value Objects等）が含まれていない
- [ ] 具体的なドメインサービス名（Quiz Domain Service等）が含まれていない
- [ ] 概念レベルの「Core Domain」「Application Layer」「Ports」「Adapters」構造のみ記述されている

**以下が適切な抽象度で含まれていることを確認**:

- 概念レベルでのデータフロー記述
- アーキテクチャパターンの選定根拠
- 技術選定の比較検討
- 通信方式の決定理由

### 品質要件

- ファイル命名規則に従って適切にファイルが分割されていること
- 作成対象が実際のファイルとして出力されていること
- Markdownのlintルールに従っていない記述が少ないこと

## 完了後

- アウトプットを全てリストアップし、ユーザーからのレビューを受ける
