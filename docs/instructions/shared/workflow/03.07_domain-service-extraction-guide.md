# ドメインサービス抽出ガイド

## 目的

- アグリゲート間の協調処理を中心としてドメインサービスを抽出し、複数のアグリゲートにまたがるビジネスロジックの適切な配置により、疎結合で保守性の高いドメインモデル設計を実現せよ

## 遵守事項

- **アグリゲート間協調重視**: 複数アグリゲートにまたがるビジネスロジックを適切にサービス化せよ
- **責任境界の明確化**: サービスの責任範囲を明確に定義し、過度な抽象化を避けよ
- **疎結合設計**: アグリゲート間の依存を最小化し、依存関係を明確に管理せよ
- **実装指針の具体化**: インターフェース設計・状態管理・パフォーマンス考慮を含む実装方針を提供せよ

## アウトプット出力先

### 基本方針

ドメインサービス抽出成果物は、ドメイン層の中核設計として、`docs/project/ddd-design/` ディレクトリに配置し、アグリゲート設計と連携したサービス境界の指針を提供する。

### 出力先ディレクトリ構造

```text
docs/project/ddd-design/
├── domain-service-extraction.md            # ドメインサービス抽出（メイン）
├── domain-services/                        # 個別サービス詳細設計
│   ├── {service-name}.service.md           # サービス詳細仕様
│   └── README.md                           # サービス一覧・関係図
├── service-coordination/                   # サービス協調設計
│   ├── cross-aggregate-analysis.md         # アグリゲート間協調分析
│   ├── service-dependencies.md             # サービス依存関係
│   └── coordination-patterns.md            # 協調パターン設計
└── service-boundaries.md                   # サービス境界・責任設計
```

**ファイル命名規則**:

- **サービス詳細**: `{ServiceName}.service.md`
- **協調パターン**: `{pattern-name}-coordination.md`
- **PascalCase使用**: サービス名はPascalCaseで統一（例：QuizApprovalService）

## ドメインサービス抽出の手順

### 1. アグリゲート間協調処理の分析

#### 1.1 クロスアグリゲート操作の特定

**参照ドキュメント**: [ドメインオブジェクト抽出ガイド](./03.05_domain-object-extraction-guide.md)、[エンティティ間関連性分析ガイド](./03.06_entity-relationship-analysis-guide.md)の成果物

**必須実施項目**:

- 複数アグリゲートが関与するビジネス操作の洗い出し
- 各操作のビジネス重要度・技術複雑度の評価
- アグリゲート境界を越える理由の明確化

**クロスアグリゲート操作分析テンプレート**:

```markdown
# アグリゲート間協調処理分析

## クロスアグリゲート操作の特定

| 操作名 | 関与アグリゲート | 協調の理由 | ビジネス重要度 | 複雑度 |
|-------|----------------|-----------|-------------|-------|
| {Operation名} | {Aggregateリスト} | {なぜ複数アグリゲートが必要か} | High/Medium/Low | High/Medium/Low |

## アグリゲート境界制約分析

| 制約名 | 制約対象アグリゲート | 制約内容 | 検証タイミング | サービス候補 |
|-------|-------------------|----------|-------------|-------------|
| {Constraint名} | {Aggregateリスト} | {具体的制約} | {いつ検証するか} | {候補サービス名} |
```

#### 1.2 サービス化判定基準の適用

**サービス化判定基準**:

```markdown
## サービス化判定チェックリスト

### 必須条件（いずれか）
- [ ] 複数のアグリゲートが関与する
- [ ] 単一エンティティでは実現できない複雑なビジネスロジック
- [ ] ステートレスな計算・変換処理
- [ ] 外部システムとの統合ロジック

### 除外条件（該当する場合はエンティティで実装）
- [ ] 単一エンティティの状態変更のみ
- [ ] 単純なCRUD操作
- [ ] UI表示用のフォーマット処理
- [ ] インフラストラクチャ層の責任
```

### 2. ドメインサービス候補の抽出

#### 2.1 サービス候補一覧作成

**サービス候補抽出テンプレート**:

```markdown
# ドメインサービス候補抽出

## サービス候補一覧

| サービス名 | 責任範囲 | 関与アグリゲート | 抽出理由 | 代替案検討 |
|----------|----------|----------------|----------|-----------|
| {Service名} | {責任内容} | {Aggregateリスト} | {なぜサービスが必要か} | {Entity/ValueObjectでは不可な理由} |

## サービス協調パターン

| サービス名 | 協調パターン | 実行順序 | 失敗時処理 | 一貫性レベル |
|----------|-------------|----------|-----------|-------------|
| {Service名} | Orchestration/Choreography | {実行順} | {エラー処理} | Strong/Eventual |
```

#### 2.2 協調パターンの選択

**協調パターンの分類**:

| パターン | 特徴 | 適用場面 | 実装方針 |
|---------|------|----------|----------|
| **Orchestration** | 中央制御・順次実行 | 複雑なビジネス処理・トランザクション必要 | ドメインサービスで制御 |
| **Choreography** | 分散制御・イベント駆動 | 疎結合・非同期処理可能 | ドメインイベント使用 |

### 3. サービス間依存関係の設計

#### 3.1 依存関係マップの作成

**サービス依存関係テンプレート**:

```markdown
# サービス間依存関係設計

## サービス依存マップ

| サービスA | サービスB | 依存関係 | 依存理由 | 疎結合化方針 |
|----------|----------|----------|----------|-------------|
| {ServiceA名} | {ServiceB名} | {依存種別} | {なぜ依存するか} | {疎結合化方法} |

## 循環依存チェック

| 依存チェーン | 循環有無 | 問題点 | 解決策 | 実装方針 |
|-------------|----------|--------|--------|----------|
| {A→B→C→...} | Yes/No | {問題内容} | {解決方法} | {実装アプローチ} |
```

#### 3.2 依存関係可視化

**依存関係図**:

```mermaid
graph TD
    A[ServiceA] --> B[AggregateB]
    A --> C[AggregateC]
    D[ServiceD] --> A
    D --> E[AggregateE]
    
    %% 疎結合化
    A -.->|Domain Event| F[ServiceF]
    F --> G[AggregateG]
```

### 4. サービス境界の設計

#### 4.1 責任分離設計

**責任分離テンプレート**:

```markdown
# サービス境界設計

## 責任分離設計

| サービス名 | コア責任 | 除外する責任 | 境界理由 | インターフェース設計 |
|----------|----------|-------------|----------|-------------------|
| {Service名} | {主責任} | {含めない責任} | {境界設定理由} | {メソッドシグネチャ} |

## 外部依存管理

| サービス名 | 外部依存 | 依存理由 | 抽象化方法 | テスト戦略 |
|----------|----------|----------|-----------|-----------|
| {Service名} | {外部システム/DB等} | {なぜ依存するか} | {Interface/Port等} | {Mock/Stub戦略} |
```

#### 4.2 インターフェース設計

**インターフェース設計原則**:

- **入力検証**: サービス境界で入力値の妥当性を検証
- **戻り値設計**: 成功・失敗・部分成功を明確に表現
- **例外設計**: ドメイン例外とシステム例外を区別
- **型安全性**: TypeScriptの型システムを活用した設計

### 5. サービス実装方針

#### 5.1 状態管理方針

**状態管理設計テンプレート**:

```markdown
# サービス実装方針

## 状態管理方針

| サービス名 | ステートレス度 | 状態保持理由 | 状態管理方法 | スレッドセーフ対応 |
|----------|-------------|-------------|-------------|-------------------|
| {Service名} | 完全/部分/ステートフル | {状態が必要な理由} | {状態管理方法} | {同期化戦略} |

## パフォーマンス考慮

| サービス名 | 性能要件 | ボトルネック要因 | 最適化戦略 | 監視項目 |
|----------|----------|----------------|-----------|----------|
| {Service名} | {レスポンス時間等} | {予想ボトルネック} | {最適化方法} | {監視指標} |
```

#### 5.2 実装テンプレート

**TypeScript実装テンプレート**:

```typescript
// ドメインサービスインターフェース
interface {ServiceName}Service {
  {methodName}({parameters}): Promise<{ResultType}>;
}

// 実装例
class {ServiceName}ServiceImpl implements {ServiceName}Service {
  constructor(
    private {aggregateA}Repository: {AggregateA}Repository,
    private {aggregateB}Repository: {AggregateB}Repository
  ) {}

  async {methodName}({parameters}): Promise<{ResultType}> {
    // 入力検証
    // ビジネスロジック実行
    // 結果返却
  }
}
```

## 完了判定基準

### 必須要件

- **アグリゲート間協調の明確化**: 複数アグリゲートが関与する処理が適切にサービス化されている
- **サービス責任の明確化**: 各サービスのコア責任と境界が明確に定義されている
- **依存関係の管理**: サービス間・サービス-アグリゲート間の依存が適切に設計されている
- **実装指針の提供**: インターフェース・状態管理・パフォーマンスの実装方針が明確

### 品質要件

- **疎結合性**: アグリゲート間の依存が最小化され、変更影響が局所化されている
- **テスタビリティ**: 外部依存が抽象化され、単体テストが容易
- **拡張性**: 新しい協調処理の追加・既存サービスの変更が容易
- **保守性**: ビジネスロジックが適切に分離され、変更時の影響範囲が明確

### 文書品質要件

- **表形式の活用**: サービス分析・依存関係・実装方針が表形式で整理されている
- **図表による可視化**: Mermaidによる依存関係・協調パターンが可視化されている
- **実装例の提供**: TypeScriptでのインターフェース・実装例が記載されている
- **判定基準の明確化**: サービス化の判定基準・代替案検討が明確に記録されている

## 完了後の必須アクション

1. **直ちに**ユーザーに「ドメインサービス抽出・協調設計」のレビューを依頼する
2. **ADR作成**: 以下の重要なサービス設計決定について、必ずADRを作成する：
   - **サービス抽出基準決定**: アグリゲート間協調を重視した抽出基準選択理由
   - **協調パターン選択決定**: Orchestration vs Choreographyの選択根拠
   - **依存関係管理戦略決定**: サービス間依存の疎結合化戦略選択理由
   - **状態管理方針決定**: ステートレス vs ステートフル設計の選択根拠
3. **ADR作成手順**:
   - 各ADRは「Proposed」ステータスで作成
   - ADRインデックス（`docs/project/adr/README.md`）への追加
   - DDD設計ドキュメント（`docs/project/ddd-design/README.md`）からのリンク追加
4. **次工程の判断**をユーザーに委ねる：
   - 通常フロー：「集約設計」「境界づけられたコンテキスト定義」に進む
   - 並行フロー：「API設計」でサービスインターフェースの詳細化
   - 戻りフロー：サービス設計に基づくアグリゲート境界・責任の見直し
5. ユーザーの明示的な承認を得てから指定された工程に進む

## 📊 ドメインサービス抽出アプローチ比較

このガイドは**アグリゲート間協調型**を基本アプローチとしているが、プロジェクト特性に応じて以下の4つのアプローチから最適な手法を選択できる：

### 4つのアプローチ比較表

| 項目 | 案1: アグリゲート間協調型 | 案2: ビジネスロジック複雑度型 | 案3: 外部統合中心型 | 案4: Sagaワークフロー型 |
|------|--------------------------|----------------------------|-------------------|---------------------|
| **2024年トレンド適合** | ✅ 最高 | ✅ 高 | ✅ 高 | ✅ 高 |
| **実装指針明確さ** | ✅ 高 | ✅ 高 | 🔶 中 | 🔶 中 |
| **マイクロサービス対応** | ✅ 高 | 🔶 中 | ✅ 最高 | ✅ 最高 |
| **複雑度管理** | 🔶 中 | ✅ 最高 | 🔶 中 | ❌ 低 |
| **学習コスト** | 🔶 中 | ❌ 高 | ❌ 高 | ❌ 最高 |
| **開発・保守工数** | 🔶 中 | 🔶 中 | ❌ 高 | ❌ 最高 |
| **テスタビリティ** | ✅ 高 | ✅ 高 | ✅ 高 | 🔶 中 |
| **運用・監視要求** | 🔶 中 | 🔶 中 | ❌ 高 | ❌ 最高 |

### 🎯 プロジェクト特性別推奨アプローチ

#### 🥇 最優先推奨：アグリゲート間協調型（このガイドのアプローチ）

**適用場面**：

- ほぼ全ての場合（特に複雑なドメインロジックがある場合）
- 複数のアグリゲートが関与するビジネスルールがある
- チーム開発で責任分離を明確化したい
- DDDの基本原則に忠実に従いたい

**推奨理由**：

1. **DDD本質適合**: 2024年DDD専門家が最も推奨する「複数アグリゲートにまたがるロジック」の適切な扱い
2. **実用性**: 具体的で理解しやすい抽出基準と設計指針
3. **バランス**: 複雑すぎず単純すぎない適切な抽象化レベル
4. **保守性**: アグリゲート境界の明確化によるコード保守性向上
5. **チーム開発**: 責任分離による効果的な分業と協業

**2024年エビデンス**:

- ExploreDDD 2024: "アグリゲート間の協調処理がドメインサービスの主要用途"
- Microsoft .NET ガイド: "複数エンティティにまたがるロジックがドメインサービス候補"
- DDD実践者コミュニティ: "エンティティ・値オブジェクトに属さないロジックの適切な配置"

#### 🥈 第2推奨：ビジネスロジック複雑度型

**適用場面**：

- アルゴリズム・計算処理が重要なシステム
- 定量的な品質管理を重視するプロジェクト
- 機械学習・最適化・分析処理が多いシステム
- アルゴリズム専門家と業務専門家が分業するチーム

**推奨理由**：

1. **客観的判断**: 定量的指標による客観的なサービス抽出判断
2. **品質管理**: 継続的な複雑度監視による品質向上
3. **専門性分離**: アルゴリズム専門知識とビジネス知識の適切な分離
4. **現代的**: 2024年の品質管理・メトリクス重視トレンドに対応

#### 🥉 第3推奨：外部統合中心型

**適用場面**：

- マイクロサービス・分散システム中心の場合
- 外部API・レガシーシステム統合が多い
- クラウドサービス統合が重要
- イベント駆動アーキテクチャ採用時

**推奨理由**：

1. **統合特化**: 外部システム統合に特化した専門的アプローチ
2. **マイクロサービス適合**: サービス境界・統合パターンが明確
3. **現代的アーキテクチャ**: API-first設計・イベント駆動に最適化
4. **運用重視**: 監視・ログ・障害処理が体系化

#### 🏅 第4推奨：Sagaワークフロー型

**適用場面**：

- 分散トランザクション・長期プロセスが中心
- マイクロサービス間の複雑な業務フローがある
- イベントソーシング・CQRSを全面採用
- 高度な分散システム設計が必要

**推奨理由**：

1. **分散処理特化**: 分散環境での複雑なワークフロー管理に特化
2. **耐障害性**: 補償処理・リトライ・冪等性を体系的に設計
3. **スケーラビリティ**: 非同期処理による高スケーラビリティ実現
4. **監査対応**: プロセス実行履歴の完全な追跡可能性

### 🔄ハイブリッド運用の提案

多くのプロジェクトでは、**段階的なハイブリッド運用**が現実的：

#### Phase 1: アグリゲート間協調でスタート

- プロジェクト初期は本ガイドのアプローチでDDD基本原則重視
- 核心ビジネスロジックの適切なサービス化
- チーム全体での責任分離・協調パターン確立

#### Phase 2: 特化アプローチを選択的追加

- **複雑アルゴリズム重要時**: ビジネスロジック複雑度型を追加
- **外部統合増加時**: 外部統合中心型を追加
- **分散処理必要時**: Sagaワークフロー型を追加

## 参考：アプローチ選択理由

### アグリゲート間協調型の採用理由

**選択根拠**:

- ✅ **DDD本質適合**: 2024年DDD専門家が最も推奨する複数アグリゲート協調の適切な扱い
- ✅ **明確な責任分離**: アグリゲート境界を越える処理の適切な配置
- ✅ **実用性**: 具体的で理解しやすい抽出基準と設計指針
- ✅ **保守性向上**: ビジネスロジックの一元化と変更影響の局所化

**2024年DDD専門家推奨度**: **最高**（DDD本来の目的に最も適合した現代的手法として評価）

この選択により、DDDの本質に忠実で実装しやすいドメインサービス設計が実現される。
