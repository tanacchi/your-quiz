# 本実装

## 目的

- 単体テスト実装（TDD）で検証された設計に基づき、ビジネス要求を満たす高品質で保守性の高いプロダクションコードを実装し、BDDテストとE2Eテストで総合的に検証される完全なアプリケーションを構築せよ

## 遵守事項

- **Test-Drivenで実装済みのテストを必ず通すこと**
- **TypeScript厳格ルールの完全遵守**: any型、as型アサーション、Non-null assertion（!）を絶対に使用しない
- **Clean Architectureの階層分離を厳密に守る**: 依存関係の方向を必ず内側（ドメイン）向きに統一
- **DRY原則とSOLID原則を適用**: 重複コードの排除と単一責任の徹底
- **エラーハンドリングとロギングを必須実装**: 適切な例外処理と運用監視に必要なログ出力
- **既存のTDDテストケースを全て通すこと**を実装完了の必要条件とする
- **パフォーマンスとセキュリティを考慮**した実装を行う
- **問題発生時の対応原則**: 問題が発生した場合は、事実やベストプラクティスを調査して対応方針を提示すること。3回の試行・検討でも解決できない場合は、状況を詳細に説明してユーザーに指示を仰ぐこと

## アウトプット出力先

### ファイル命名規則

- **エンティティ**: `{名前}.entity.ts`
- **値オブジェクト**: `{名前}.value-object.ts`
- **ユースケース**: `{動詞}{対象}.use-case.ts`
- **リポジトリ**: `{名前}.repository.ts`、`{名前}.repository.interface.ts`
- **コントローラー**: `{名前}.controller.ts`

## 本実装の手順

### 前提条件

**BDD実装済み状態からの段階的実装**: BDDテストが既に実装・実行可能状態であることを前提とした、段階的かつレビュー駆動の実装手順を以下に示す。

### 実装ステップとレビュー依頼タイミング

#### ステップ1: インターフェース・スケルトン実装 + レビュー依頼

**目的**: BDDテストを実行して「メソッド参照エラー」から「アウトプット不一致エラー」の状態に移行

**実装内容**:

- BDDテストが要求するクラス・インターフェースの定義
- 空のメソッド実装（デフォルト値・例外throw等）
- 必要な型定義・DTOの基本構造

**実装例**:

```typescript
// ユーザー登録ユースケース（空実装）
export class RegisterUserUseCase {
  async execute(request: RegisterUserRequest): Promise<RegisterUserResponse> {
    throw new Error('Not implemented');
  }
}

// レスポンスDTO
export interface RegisterUserResponse {
  id: string;
  email: string;
  status: string;
}
```

**完了条件**: BDDテストが「Method not found」エラーではなく「Assertion failed」エラーになる

**📋 レビュー依頼**: インターフェース設計・型定義の妥当性レビューを依頼

---

#### ステップ2: アーキテクチャスケルトン実装 + レビュー依頼

**目的**: Clean Architectureの層構造と依存関係を明確にした実装骨格を作成

**実装内容**:

- ドメイン層：エンティティ・値オブジェクト・リポジトリIF
- アプリケーション層：ユースケース・DTO・ポート
- インフラ層：リポジトリ実装・コントローラー
- 依存関係注入設定

**実装例**:

```typescript
// ドメイン層
export class User {
  constructor(private id: UserId, private email: Email) {}
  // メソッドは空実装
}

// アプリケーション層
export class RegisterUserUseCase {
  constructor(
    private userRepository: IUserRepository,
    private emailService: IEmailService
  ) {}

  async execute(request: RegisterUserRequest): Promise<RegisterUserResponse> {
    // 骨格のみ - 実装は後続ステップ
    const user = new User(/* empty */);
    return { id: '', email: '', status: '' };
  }
}
```

**完了条件**:

- Clean Architectureの層分離が明確
- 依存関係の方向が内側向きに統一
- DIコンテナ設定が完了

**📋 レビュー依頼**: アーキテクチャ設計・依存関係構造のレビューを依頼

---

#### ステップ3: TDDテスト実装 + レビュー依頼

**目的**: 各コンポーネントの詳細仕様をテストファーストで定義

**実装内容**:

- 単体テストケース実装（失敗状態）
- モック・スタブ定義
- テストデータ・シナリオ準備
- 例外系テストケース

**実装例**:

```typescript
describe('RegisterUserUseCase', () => {
  it('should register new user successfully', async () => {
    // Arrange
    const mockRepository = createMock<IUserRepository>();
    const mockEmailService = createMock<IEmailService>();
    const useCase = new RegisterUserUseCase(mockRepository, mockEmailService);

    const request = { email: 'test@example.com', name: 'Test User' };

    // Act & Assert
    const result = await useCase.execute(request);
    expect(result.id).toBeDefined();
    expect(result.email).toBe('test@example.com');
  });
});
```

**完了条件**: 全テストが「Red」状態（実装前なので失敗）

**📋 レビュー依頼**: テスト設計・カバレッジ・例外ケースのレビューを依頼

---

#### ステップ4: TDD実装（Red → Green） + レビュー依頼

**目的**: TDDサイクルに従って各テストを順次Green状態にする

**実装内容**:

- 各テストを通すための最小実装
- リファクタリング（重複排除・可読性向上）
- エラーハンドリング・ロギング実装
- パフォーマンス・セキュリティ考慮実装

**実装例**:

```typescript
export class RegisterUserUseCase {
  async execute(request: RegisterUserRequest): Promise<RegisterUserResponse> {
    // 1. バリデーション
    this.validateRequest(request);

    // 2. ドメインオブジェクト生成
    const email = Email.create(request.email);
    const user = User.create(UserId.generate(), email, request.name);

    // 3. 永続化
    await this.userRepository.save(user);

    // 4. 通知
    await this.emailService.sendWelcomeEmail(user.getEmail());

    // 5. レスポンス生成
    return {
      id: user.getId().getValue(),
      email: user.getEmail().getValue(),
      status: 'PENDING_VERIFICATION'
    };
  }
}
```

**完了条件**:

- 全単体テストがGreen
- カバレッジ95%以上達成
- TypeScript厳格ルール遵守

**📋 レビュー依頼**: 実装品質・パフォーマンス・セキュリティのレビューを依頼

---

#### ステップ5: BDD統合テスト実行・修正 + レビュー依頼

**目的**: BDDテストを実行し、ビジネス仕様との整合性を確認・修正

**実装内容**:

- BDDテスト実行・結果分析
- ビジネスロジックの細かな調整
- 統合部分のバグ修正
- エラーメッセージ・レスポンス形式の調整

**完了条件**:

- 全BDDテストがGreen
- ビジネス仕様との完全な整合性
- エラーケースの適切な処理

**📋 レビュー依頼**: ビジネス要件適合性・統合動作のレビューを依頼

### インクリメンタル実装の指針

**分解原則**: 各ステップは必要に応じてさらに細分化して実装する

**分解例**:

- ステップ1: 主要ユースケース → 例外系ユースケース → 補助機能
- ステップ2: コア層 → サービス層 → インフラ層
- ステップ4: 正常系実装 → 例外系実装 → 最適化実装

**レビュー単位**:

- 機能単位での分割レビュー（ユーザー管理、商品管理等）
- 層単位での分割レビュー（ドメイン層、アプリ層等）
- 関心事単位での分割レビュー（認証、決済、通知等）

### 1. 実装前準備

#### 1.1 テスト環境確認

**既存TDDテストの実行状況を確認せよ**:

- 全単体テストがGreenで通過している
- テストカバレッジが95%以上達成している
- BDDテストが定義され実行可能状態にある

#### 1.2 技術スタック確認

**選定済み技術スタックの設定を確認せよ**:

- フレームワーク・ライブラリのバージョン
- TypeScript設定（strict: true、noImplicitAny: true等）
- Linter・Formatter設定（ESLint、Prettier）
- DI コンテナ設定（InversifyJS、Awilix等）

### 2. ドメイン層実装

#### 2.1 エンティティ実装

**ビジネス不変条件を実装せよ**:

**必須実装項目**:

- 不変条件の検証（コンストラクタ・ファクトリーメソッド）
- ビジネスルールの実装（状態変更メソッド）
- ドメインイベントの発行
- 等価性・ハッシュコード実装

#### 2.2 値オブジェクト実装

**不変性とバリデーションを実装せよ**:

- 値の不変性保証
- ファクトリーメソッドでのバリデーション
- 等価性比較メソッド
- 型安全性の確保

#### 2.3 ドメインサービス実装

**エンティティ間の複雑なビジネスロジックを実装せよ**:

- ユニークネス検証（メールアドレス重複チェック）
- 複数エンティティにまたがるビジネスルール
- ドメイン計算ロジック

#### 2.4 リポジトリインターフェース定義

**永続化の抽象化を定義せよ**:

- CRUD操作の抽象化
- ドメイン固有の検索メソッド
- Result型を使用した戻り値設計
- エラーハンドリングの抽象化

### 3. アプリケーション層実装

#### 3.1 ユースケース実装

**ビジネスユースケースを実装せよ**:

**必須実装項目**:

- 入力バリデーション
- トランザクション境界の管理
- ドメインイベントの発行
- エラーハンドリング
- DTO変換

#### 3.2 DTO・マッパー実装

**レイヤー間のデータ変換を実装せよ**:

- ドメインオブジェクト ↔ DTO変換
- 外部サービス ↔ ドメインオブジェクト変換
- バリデーション付きDTO実装

### 4. インフラストラクチャ層実装

#### 4.1 リポジトリ実装

**データ永続化の具体実装を行え**:

**必須実装項目**:

- データベーススキーマとの適合性
- トランザクション管理
- 例外のドメインエラーへの変換
- パフォーマンス最適化（N+1問題対策等）

#### 4.2 Webコントローラー実装

**HTTP/REST APIを実装せよ**:

**必須実装項目**:

- OpenAPI仕様との整合性
- HTTPステータスコードの適切な使用
- セキュリティヘッダーの設定
- レート制限・CORS設定

#### 4.3 外部サービス統合

**外部APIとの統合を実装せよ**:

- 認証・認可サービス
- メール送信サービス
- ファイルストレージ
- 通知サービス

### 5. 共通基盤実装

#### 5.1 エラーハンドリング

**統一的なエラー処理を実装せよ**:

**必須実装項目**:

- カスタム例外クラス定義
- エラーコード・メッセージ管理
- スタックトレース保持
- ログ出力との連携

#### 5.2 ロギング

**運用監視に必要なログを実装せよ**:

- 構造化ログ（JSON形式）
- ログレベル（DEBUG、INFO、WARN、ERROR）
- コンテキスト情報（ユーザーID、リクエストID）
- パフォーマンスメトリクス

#### 5.3 設定管理・DI

**環境別設定とDIコンテナを実装せよ**:

- 環境変数による設定管理
- 開発・本番環境の切り替え
- DIコンテナによる依存関係解決
- シークレット管理

### 6. パフォーマンス・セキュリティ

#### 6.1 パフォーマンス最適化

**応答性能を確保せよ**:

- データベースクエリ最適化
- キャッシュ戦略実装
- 非同期処理・バッチ処理
- メモリ使用量最適化

#### 6.2 セキュリティ実装

**セキュリティ要件を満たせ**:

- 入力検証・サニタイゼーション
- SQLインジェクション対策
- XSS・CSRF対策
- 認証・認可の実装

### 7. テスト統合・検証

#### 7.1 TDDテスト実行

**既存テストとの整合性確認を行え**:

- 全単体テストの実行・合格確認
- カバレッジレポート生成
- テスト失敗時の原因分析・修正

#### 7.2 BDDテスト実行

**ビジネス仕様の実装確認を行え**:

- Given-When-Thenシナリオの実行
- ビジネスルールの動作確認
- エラーケースの適切な処理

#### 7.3 統合テスト

**コンポーネント間連携の確認を行え**:

- API統合テスト
- データベース統合テスト
- 外部サービス連携テスト

## 完了判定基準

### 機能実装の完了

- **全TDDテストがGreen**: 既存の単体テストが100%成功している
- **BDDテストがGreen**: ビジネスシナリオが全て成功している
- **API仕様準拠**: OpenAPIドキュメントとの完全な整合性
- **Clean Architecture遵守**: 依存関係の方向性が正しく実装されている

### 品質要件の達成

- **TypeScript厳格モード**: any型、型アサーション、non-null assertionを使用していない
- **テストカバレッジ95%以上**: コード網羅性が達成されている
- **Linter・Formatter通過**: コード品質基準を満たしている
- **セキュリティ要件**: 入力検証、認証・認可が適切に実装されている

### 非機能要件の確認

- **パフォーマンス要件**: レスポンス時間・スループット基準の達成
- **エラーハンドリング**: 適切な例外処理とログ出力の実装
- **運用監視**: 本番運用に必要なログ・メトリクス出力の実装
- **設定管理**: 環境別設定とシークレット管理の実装

### 統合性・保守性の確保

- **依存関係管理**: DIコンテナによる適切な依存関係解決
- **コード構造**: Clean Architectureの層構造が明確に実装されている
- **ドキュメント更新**: APIドキュメント、設計書の更新完了
- **デプロイ準備**: 本番環境での動作確認とデプロイメント設定

## 完了後の必須アクション

1. **直ちに**ユーザーに「本実装コード」のレビューを依頼する
2. **ADR作成判断**: アーキテクチャパターン実装、パフォーマンス最適化等の重要決定について、ADRでの記録をユーザーに提案する
3. **次工程の判断**をユーザーに委ねる：
   - 通常フロー：「E2Eテスト」に進む
   - 戻りフロー：実装課題発見によるBDDテスト見直し
4. ユーザーの明示的な承認を得てから指定された工程に進む
