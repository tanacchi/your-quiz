# 技術選定

## 目的

- アーキテクチャ設計で決定された技術方針に基づき、実装で使用する具体的なライブラリ・フレームワーク・ツールを選定し、開発チームが一貫性のある技術スタックで実装を進めるため、neverthrowやORM、バリデーションライブラリなどを表形式で比較検討し、判断根拠を明示した技術選定書を作成する

## アウトプット出力先

### 基本方針

技術選定文書は、プロジェクトドキュメント体系として整理し、`docs/project/tech-selection/` ディレクトリに集約して後続工程からの参照を容易にする。

### 出力先ディレクトリ構造

```text
docs/project/tech-selection/
├── overview.md                     # 技術選定概要・方針
├── libraries/                      # ライブラリ選定
│   ├── error-handling.md           # エラーハンドリング（neverthrow等）
│   ├── orm.md                      # ORM選定
│   ├── validation.md               # バリデーション
│   ├── testing.md                  # テストフレームワーク
│   └── ui-framework.md             # UIフレームワーク
├── infrastructure/                 # インフラ技術選定
│   ├── database.md                 # データベース選定
│   ├── deployment.md               # デプロイメント
│   └── monitoring.md               # 監視・ログ
└── comparison-tables/              # 比較検討表
    └── tech-comparison-matrix.md   # 技術比較マトリクス
```

**ファイル命名規則**:

- **比較検討表**: `{カテゴリ}-comparison.md`
- **選定結果**: `{技術分野}-selection.md`

## 遵守事項

- **全ての技術選定は必ず表形式で比較検討を行う**
- **アーキテクチャ設計で決定された方針との整合性を確認する**
- **比較検討表でトレードオフを明示する**
- プロジェクト要件・チーム技術力・保守性を総合的に判断する
- ライブラリのバージョン・ライセンス・メンテナンス状況を確認する

## 技術選定の手順

### 1. アーキテクチャ方針との整合性確認

#### 1.1 前提条件の確認

- 全体技術設計で決定されたアーキテクチャパターンの確認
- 通信方式（同期/非同期）、データストア方針の確認
- 非機能要件（パフォーマンス、セキュリティ、可用性）の確認

#### 1.2 制約条件の明確化

- チーム技術力レベルの評価
- 学習コスト許容範囲の設定
- 運用・保守体制の考慮
- ライセンス制約の確認

### 2. 必須技術カテゴリの選定

#### 2.1 エラーハンドリング（neverthrow等）

**選定必須理由**: TypeScript環境での関数型エラーハンドリング統一のため

| ライブラリ | メリット | デメリット | 適用場面 | 学習コスト | メンテナンス性 | パフォーマンス | 判定 |
|------------|----------|------------|----------|------------|---------------|--------------|------|
| **neverthrow** | ・Result型提供<br>・型安全なエラー処理<br>・関数型プログラミング対応<br>・TypeScript最適化 | ・学習曲線急<br>・既存コード移行コスト<br>・チーム教育必要 | ・API結果処理<br>・ビジネスロジック<br>・外部連携 | 中 | 高 | 高 | ○ |
| fp-ts | ・高機能<br>・関数型エコシステム充実<br>・数学的厳密性 | ・学習コスト極高<br>・オーバーエンジニアリング<br>・可読性低下リスク | ・関数型プログラミング中心<br>・複雑なデータ変換 | 高 | 高 | 中 | × |
| 独自実装 | ・プロジェクト特化<br>・軽量<br>・完全制御 | ・テスト負荷<br>・保守コスト<br>・バグリスク | ・シンプルな要件<br>・特殊制約 | 低 | 低 | 高 | △ |

**選定結果**: neverthrow
**選定理由**:

- TypeScript環境に最適化されており型安全性が高い
- 学習コストは中程度でチーム導入可能
- Result型による統一的なエラーハンドリングが実現可能

#### 2.2 ORM/クエリビルダー

**選定必須理由**: データベースアクセスの統一とタイプセーフなクエリ実行のため

| ORM/ツール | メリット | デメリット | 適用場面 | 型安全性 | パフォーマンス | 学習コスト | 判定 |
|------------|----------|------------|----------|----------|---------------|------------|------|
| **Prisma** | ・強力な型生成<br>・マイグレーション機能<br>・開発体験良好<br>・インクリメンタル採用可能 | ・新しい技術<br>・複雑クエリ制限<br>・生成ファイル大<br>・ベンダーロックイン | ・TypeScript中心<br>・RAD開発<br>・プロトタイプ | 高 | 中 | 低 | ○ |
| TypeORM | ・デコレータベース<br>・Active Record対応<br>・エコシステム成熟<br>・複雑クエリ対応 | ・設定複雑<br>・実行時型チェック<br>・パフォーマンス課題<br>・メンテナンス性 | ・エンタープライズ<br>・既存システム移行<br>・複雑ドメイン | 中 | 低 | 中 | △ |
| Kysely | ・クエリビルダー<br>・型安全<br>・軽量<br>・SQL制御可能 | ・ORM機能なし<br>・マイグレーション別途<br>・学習コスト<br>・ボイラープレート | ・パフォーマンス重視<br>・SQL熟練者<br>・細かい制御 | 高 | 高 | 高 | × |

**選定結果（例）**: Prisma
**選定理由（例）**:

- TypeScript環境での型安全性が最も高い
- 開発効率とコード品質のバランスが良い
- マイグレーション機能により運用負荷が軽減

**注意**: 上記の選定結果はあくまで一例です。プロジェクトごとに要件や制約が異なるため、必ず独自の比較検討を行い、最適な技術を選定してください。

#### 2.3 バリデーションライブラリ

**選定必須理由**: API入力値検証とTypeScript型システムとの統合のため

| ライブラリ | メリット | デメリット | 適用場面 | 型推論 | パフォーマンス | エラーメッセージ | 判定 |
|------------|----------|------------|----------|--------|---------------|-----------------|------|
| **zod** | ・TypeScript First<br>・優秀な型推論<br>・カスタムバリデーション<br>・エコシステム充実 | ・ランタイムオーバーヘッド<br>・複雑スキーマで型推論遅延<br>・学習コスト | ・API入力検証<br>・設定ファイル<br>・フォーム検証 | 高 | 中 | 高 | ○ |
| yup | ・成熟ライブラリ<br>・豊富な機能<br>・Formikとの親和性<br>・学習リソース多 | ・TypeScript対応弱<br>・型推論限定的<br>・設定複雑 | ・従来型開発<br>・JavaScript中心<br>・フォーム中心 | 低 | 高 | 中 | × |
| joi | ・高機能<br>・豊富な検証ルール<br>・企業採用実績<br>・安定性 | ・TypeScript対応なし<br>・型安全性皆無<br>・学習コスト高 | ・Node.js専用<br>・既存システム<br>・複雑検証 | 無 | 高 | 高 | × |

**選定結果**: zod
**選定理由**:

- TypeScript環境での型推論が最も優秀
- API設計との整合性が保てる
- neverthrowとの組み合わせでエラーハンドリングが統一可能

#### 2.4 HTTPクライアント

**選定必須理由**: 外部API連携とエラーハンドリング統一のため

| クライアント | メリット | デメリット | 適用場面 | 型安全性 | エラーハンドリング | 設定柔軟性 | 判定 |
|-------------|----------|------------|----------|----------|------------------|------------|------|
| **axios** | ・豊富な機能<br>・エコシステム成熟<br>・インターセプター<br>・ブラウザ/Node両対応 | ・Bundle size大<br>・設定複雑<br>・TypeScript対応弱 | ・複雑API連携<br>・認証処理<br>・エラーハンドリング | 低 | 中 | 高 | ○ |
| fetch (native) | ・標準API<br>・軽量<br>・Promise対応<br>・追加依存なし | ・機能限定<br>・ブラウザ差異<br>・設定繁雑<br>・エラーハンドリング弱 | ・シンプル通信<br>・軽量アプリ<br>・モダンブラウザ限定 | 無 | 低 | 低 | △ |
| ky | ・軽量<br>・TypeScript最適化<br>・モダンAPI<br>・Promise/async最適化 | ・エコシステム小<br>・学習リソース少<br>・企業採用実績少 | ・TypeScript重視<br>・軽量アプリ<br>・モダン開発 | 中 | 中 | 中 | × |

**選定結果**: axios
**選定理由**:

- エコシステムが成熟しており安定性が高い
- 複雑なAPI連携要件に対応可能
- チームの学習コストが最も低い

### 3. 開発・テスト環境ツール

#### 3.1 テストフレームワーク

| フレームワーク | メリット | デメリット | 適用場面 | 実行速度 | TypeScript対応 | 設定容易さ | 判定 |
|---------------|----------|------------|----------|----------|---------------|------------|------|
| **Vitest** | ・Vite統合<br>・高速実行<br>・TypeScript最適<br>・Jest互換API | ・新しい技術<br>・エコシステム発展途上<br>・学習リソース限定 | ・Viteプロジェクト<br>・モダンテスト<br>・高速開発 | 高 | 高 | 高 | ○ |
| Jest | ・成熟エコシステム<br>・豊富な機能<br>・学習リソース多<br>・企業採用実績 | ・設定複雑<br>・実行速度<br>・ESM対応課題 | ・従来型開発<br>・安定性重視<br>・大規模テスト | 中 | 中 | 中 | △ |

#### 3.2 型定義・コード生成

| ツール | メリット | デメリット | 適用場面 | 型安全性 | 保守性 | 学習コスト | 判定 |
|--------|----------|------------|----------|----------|--------|------------|------|
| **openapi-typescript** | ・OpenAPI→TypeScript<br>・自動生成<br>・型安全なAPI呼び出し<br>・フロントエンド統合 | ・生成ファイル大<br>・カスタマイズ制限<br>・OpenAPI依存 | ・API型定義<br>・フロント/バック統合<br>・TypeSpec連携 | 高 | 中 | 低 | ○ |

## 技術選定結果サマリ

### 最終選定技術スタック

| カテゴリ | 選定技術 | バージョン | 選定理由 | 代替案 |
|----------|----------|------------|----------|--------|
| **エラーハンドリング** | neverthrow | ^6.0.0 | TypeScript最適化、型安全性、学習コスト適切 | fp-ts, 独自実装 |
| **ORM** | Prisma | ^5.0.0 | 型安全性最高、開発効率良、マイグレーション充実 | TypeORM, Kysely |
| **バリデーション** | zod | ^3.22.0 | TypeScript型推論優秀、neverthrowとの統合性 | yup, joi |
| **HTTPクライアント** | axios | ^1.6.0 | 成熟エコシステム、機能充実、安定性 | fetch, ky |
| **テストフレームワーク** | Vitest | ^1.0.0 | 高速実行、TypeScript最適、Vite統合 | Jest |
| **型定義生成** | openapi-typescript | ^6.7.0 | OpenAPI統合、型安全API、自動生成 | 手動定義 |

### トレードオフ受容事項

#### 受容するトレードオフ

1. **学習コスト vs 型安全性**: 新技術（Vitest, zod）の学習コストを受容し、型安全性を優先
2. **Bundle Size vs 機能性**: axios、Prismaのサイズ増加を受容し、機能性・安定性を優先
3. **新技術リスク vs 開発効率**: Vitest等の新技術採用リスクを受容し、開発効率を優先

#### 将来対応予定

1. **パフォーマンス最適化**: 必要に応じてBuild時の最適化、Code Splittingを検討
2. **技術債務管理**: 定期的なライブラリアップデート計画策定
3. **代替技術評価**: 年1回の技術選定見直し

## 完了判定基準

### 必須要件

- [x] **選定ライブラリとバージョン、理由が表形式で示されている**
- [x] **比較検討表でトレードオフが明示されている**
- [x] **プロジェクト要件を満たすことが明確になっている**
- [x] **アーキテクチャ設計との整合性が確認されている**
- [x] **チーム技術力と学習コストが考慮されている**

### 成果物

1. **技術選定比較表**
2. **最終選定技術スタック一覧**
3. **トレードオフ受容事項**
4. **導入・移行計画**

## 完了後の必須アクション

1. **直ちに**ユーザーに「技術選定リスト」のレビューを依頼する
2. **ADR作成判断**: フレームワーク、ライブラリ、データベース等の技術スタック選定について、ADRでの記録をユーザーに提案する
3. **次工程の判断**をユーザーに委ねる：
   - 通常フロー：「BDDテスト実装」に進む
   - 戻りフロー：技術制約による要件調整で前工程に戻る
4. ユーザーの明示的な承認を得てから指定された工程に進む
