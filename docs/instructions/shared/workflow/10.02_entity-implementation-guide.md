# ドメインエンティティ実装ガイド（QuizSummary準拠）

> **目的**: 型安全性とimmutabilityを実現し、QuizSummaryと同品質のドメインエンティティを確実に実装するための完全ガイド

---

## 設計原則

### コア原則

1. **EntityBase継承**: 共通機能をベースクラスから継承し、Self-type patternで型安全性を実現
2. **完全Immutability**: 全操作で新インスタンス生成、内部状態の完全保護
3. **Result型エラーハンドリング**: neverthrowによる型安全なエラー処理
4. **Patch System**: 自動修正候補提案による堅牢なバリデーション
5. **Brand型活用**: ランタイムスキーマとしても機能する厳密な型システム

### アーキテクチャ概要

```typescript
// 継承構造
EntityBase<TEntity, TSchema>  // 共通CRUD操作
  ↑
QuizSummary extends EntityBase<QuizSummary, typeof QuizSummarySchema>

DraftBase<TEntity, TSchema>   // 共通Draft操作
  ↑
QuizSummary.Draft extends DraftBase<QuizSummary, typeof QuizSummarySchema>
```

---

## ファイル配置規約

```txt
src/contexts/{context-name}/domain/entities/
└── {entity-name}/
    ├── {EntityName}.ts          # メインエンティティクラス + parse関数
    ├── {EntityName}.spec.ts     # 包括的テストスイート
    ├── {entity-name}-schema.ts  # Zodスキーマ + Brand型定義
    └── {entity-name}-patches.ts # パッチシステム（自動修正候補）
```

---

## Schema File実装パターン

**ファイル名**: `{entity-name}-schema.ts`

### Brand型定義

```typescript
import { z } from "zod";

// Brand types - ランタイムスキーマとしても機能
export const QuizId = z.string().min(1).brand<"QuizId">();
export type QuizId = z.infer<typeof QuizId>;

export const SolutionId = z.string().min(1).brand<"SolutionId">();
export type SolutionId = z.infer<typeof SolutionId>;

export const CreatorId = z.string().min(1).brand<"CreatorId">();
export type CreatorId = z.infer<typeof CreatorId>;

export const TagId = z.string().min(1).brand<"TagId">();
export type TagId = z.infer<typeof TagId>;

// Transform型 - null/undefinedを適切にデフォルト値に変換
export const TagIds = z
  .array(TagId)
  .nullish()
  .transform((val) => val ?? []);
export type TagIds = z.infer<typeof TagIds>;
```

### メインスキーマ定義

```typescript
import { dateStringOnlySchema } from "../../../../../shared/schemas/datetime.schema";

export const QuizSummarySchema = z
  .object({
    id: QuizId,
    question: z.string().min(1),
    answerType: z.enum([
      "boolean",
      "free_text",
      "single_choice",
      "multiple_choice",
    ]),
    solutionId: SolutionId,
    explanation: z.string().optional(),
    tagIds: TagIds,
    status: z.enum(["pending_approval", "approved", "rejected"]),
    creatorId: CreatorId,
    createdAt: dateStringOnlySchema,
    approvedAt: dateStringOnlySchema.optional(),
  })
  .strict()                    // 予期しないフィールドを拒否
  .superRefine((quiz, ctx) => {
    // クロスフィールド制約
    if (quiz.status === "approved" && !quiz.approvedAt) {
      ctx.addIssue({
        code: "custom",
        message: "Approved quiz must have approvedAt timestamp",
        path: ["approvedAt"],
      });
    }

    // ビジネスルール検証
    const uniqueTagIds = new Set(quiz.tagIds);
    if (uniqueTagIds.size !== quiz.tagIds.length) {
      ctx.addIssue({
        code: "custom",
        message: "Duplicate tag IDs are not allowed",
        path: ["tagIds"],
      });
    }
  });

// 型エクスポート
export type QuizSummaryData = z.output<typeof QuizSummarySchema>;
export type QuizSummaryInput = z.input<typeof QuizSummarySchema>;
```

---

## Patches File実装パターン

**ファイル名**: `{entity-name}-patches.ts`

### 基本構造

```typescript
import {
  applyEntityPatch,
  applyEntityPatches,
  type EntityPatch,
  type FieldSuggester,
  type Issue,
  materializeEntityPatch,
} from "../../../../../shared/validation/entity";
import type { QuizSummaryInput } from "./quiz-summary-schema";

// 型エイリアス
export type QuizSummaryPatch = EntityPatch<QuizSummaryInput>;
type QuizSummaryFieldSuggester = FieldSuggester<QuizSummaryInput>;

// 型ガード
const isQuizSummaryLike = (
  input: unknown,
): input is Partial<QuizSummaryInput> => {
  return typeof input === "object" && input !== null;
};

// ユーティリティの再エクスポート（エンティティ固有名で）
export const materializePatch = materializeEntityPatch<QuizSummaryInput>;
export const applyQuizSummaryPatch = (
  input: unknown,
  patch: QuizSummaryPatch,
): unknown => applyEntityPatch(input, patch);
export const applyQuizSummaryPatches = (
  input: unknown,
  patches: QuizSummaryPatch[],
): unknown => applyEntityPatches(input, patches);
```

### フィールド別サジェスト関数

```typescript
// question用：trim + 空文字列への対応
export const suggestQuestionPatches: QuizSummaryFieldSuggester = (value) => {
  if (typeof value !== "string") return [];

  const patches: QuizSummaryPatch[] = [];
  const trimmed = value.trim();

  if (trimmed !== value && trimmed.length > 0) {
    patches.push({ question: trimmed });
  } else if (trimmed === "") {
    patches.push({ question: "Sample question" });
  }

  return patches;
};

// ID fields用：汎用trim関数
export const suggestIdFieldPatches =
  (fieldName: keyof QuizSummaryInput) =>
  (value: unknown): QuizSummaryPatch[] => {
    if (typeof value !== "string") return [];

    const patches: QuizSummaryPatch[] = [];
    const trimmed = value.trim();

    if (trimmed !== value) {
      patches.push({ [fieldName]: trimmed } as Partial<QuizSummaryInput>);
    }

    return patches;
  };

// enum用：typo修正マッピング
export const suggestAnswerTypePatches: QuizSummaryFieldSuggester = (value) => {
  if (typeof value !== "string") return [];

  const patches: QuizSummaryPatch[] = [];
  const answerType = value.toLowerCase();
  const suggestionMap = {
    single: "single_choice",
    multiple: "multiple_choice",
    bool: "boolean",
    boolean_choice: "boolean",
    free: "free_text",
    text: "free_text",
  } as const;

  for (const [typo, correct] of Object.entries(suggestionMap)) {
    if (answerType.includes(typo)) {
      patches.push({ answerType: correct });
      break;
    }
  }

  return patches;
};

// array用：null/undefinedハンドリング + フィルタリング
export const suggestTagIdsPatches: QuizSummaryFieldSuggester = (value) => {
  const patches: QuizSummaryPatch[] = [];

  if (value == null) {
    patches.push({ tagIds: [] });
  } else if (Array.isArray(value)) {
    // 遅延計算関数として実装（複雑な変換処理）
    patches.push(() => {
      const validTagIds = value
        .filter((x: unknown) => typeof x === "string")
        .map((x: string) => x.trim())
        .filter((x: string) => x.length > 0);
      return { tagIds: validTagIds };
    });
  }

  return patches;
};
```

### 集約サジェスト関数

```typescript
// Issue発生フィールドのみ処理する効率的な集約
export const suggestQuizSummaryPatches = (
  input: unknown,
  issues: Issue[],
): QuizSummaryPatch[] => {
  if (!isQuizSummaryLike(input)) {
    return [];
  }

  const needsField = (field: string) =>
    issues.some((issue) => String(issue.path[0]) === field);

  const patches: QuizSummaryPatch[] = [];

  if (needsField("question")) patches.push(...suggestQuestionPatches(input.question));
  if (needsField("explanation")) patches.push(...suggestExplanationPatches(input.explanation));
  if (needsField("id")) patches.push(...suggestIdFieldPatches("id")(input.id));
  if (needsField("solutionId")) patches.push(...suggestIdFieldPatches("solutionId")(input.solutionId));
  if (needsField("creatorId")) patches.push(...suggestIdFieldPatches("creatorId")(input.creatorId));
  if (needsField("answerType")) patches.push(...suggestAnswerTypePatches(input.answerType));
  if (needsField("status")) patches.push(...suggestStatusPatches(input.status));
  if (needsField("tagIds")) patches.push(...suggestTagIdsPatches(input.tagIds));
  if (needsField("approvedAt")) patches.push(...suggestApprovedAtPatches(input));

  return patches;
};
```

---

## Main Entity File実装パターン

**ファイル名**: `{EntityName}.ts`

### 基本構造と型定義

```typescript
import { err, ok } from "neverthrow";
import {
  DraftBase,
  EntityBase,
  type EntityParseError,
  type EntityParseResult,
  type EntityPatch,
  toIssues,
} from "../../../../../shared/validation/entity";
import { suggestQuizSummaryPatches } from "./quiz-summary-patches";
import {
  type QuizSummaryData,
  type QuizSummaryInput,
  QuizSummarySchema,
  type TagId,
} from "./quiz-summary-schema";

// エンティティ固有型エイリアス
export type QuizSummaryPatch = EntityPatch<QuizSummaryInput>;
export type QuizSummaryParseError = EntityParseError<QuizSummaryInput>;
export type QuizSummaryParseResult = EntityParseResult<
  QuizSummary,
  QuizSummaryInput
>;

// 後方互換エイリアス
export type QuizSummaryDraft = InstanceType<typeof QuizSummary.Draft>;
```

### 包括的な再エクスポート

```typescript
// 共通ユーティリティの再エクスポート
export type { Issue } from "../../../../../shared/validation/entity";
export {
  applyEntityPatch,
  applyEntityPatches,
  materializeEntityPatch,
} from "../../../../../shared/validation/entity";

// Schema型の公開API再エクスポート
export type {
  CreatorId as CreatorIdType,
  QuizId as QuizIdType,
  QuizSummaryData,
  QuizSummaryInput,
  SolutionId as SolutionIdType,
  TagDetail,
  TagId as TagIdType,
} from "./quiz-summary-schema";

// ランタイムBrand型スキーマの再エクスポート
export {
  CreatorId,
  QuizId,
  SolutionId,
  TagId,
} from "./quiz-summary-schema";
```

### Parse関数実装

```typescript
/**
 * parseQuizSummary: エンティティの統一エントリーポイント
 * - 成功: ok(QuizSummary)
 * - 失敗: err({ issues, patches })
 *   - patches は候補のみ、採用判断は呼び出し側
 */
export function parseQuizSummary(input: unknown): QuizSummaryParseResult {
  const parsed = QuizSummarySchema.safeParse(input);
  if (parsed.success) return ok(QuizSummary.build(parsed.data));

  const issues = toIssues(parsed.error);
  const patches = suggestQuizSummaryPatches(input, issues);
  return err({ kind: "parse", issues, patches });
}
```

### エンティティクラス実装

```typescript
/**
 * QuizSummary Entity - Self-type patternによる型安全なimmutableエンティティ
 */
export class QuizSummary extends EntityBase<
  QuizSummary,
  typeof QuizSummarySchema
> {
  constructor(data: QuizSummaryData) {
    super(data, parseQuizSummary);
  }

  /** 検証済みデータからの内部ファクトリメソッド */
  static build(data: QuizSummaryData): QuizSummary {
    return new QuizSummary(data);
  }

  /**
   * 未知の入力からエンティティインスタンスを作成
   */
  static from(input: unknown): QuizSummaryParseResult {
    return parseQuizSummary(input);
  }

  /**
   * DraftインスタンスからエンティティをコミットDraftのcommit()に委譲）
   */
  static fromDraft(
    draft: InstanceType<typeof QuizSummary.Draft>,
  ): QuizSummaryParseResult {
    return draft.commit();
  }

  // EntityBaseから継承される共通メソッド:
  // - toData(): QuizSummaryData
  // - get<K>(key: K): QuizSummaryData[K]
  // - update<K>(key: K, value: QuizSummaryInput[K]): QuizSummaryParseResult
  // - with(patch: Partial<QuizSummaryInput>): QuizSummaryParseResult
  // - withMutator(mutator: (draft: QuizSummaryInput) => void): QuizSummaryParseResult

  // ビジネスロジックメソッド
  canBeUpdated(): boolean {
    return this.get("status") === "pending_approval";
  }

  canBeDeleted(): boolean {
    return this.get("status") !== "approved";
  }

  approve(approvedAt: string): QuizSummaryParseResult {
    if (this.get("status") !== "pending_approval") {
      const error: QuizSummaryParseError = {
        kind: "parse",
        issues: [
          {
            path: ["status"],
            code: "custom",
            message: `Quiz with status ${this.get("status")} cannot be approved`,
          },
        ],
        patches: [],
      };
      return err(error);
    }

    return this.with({
      status: "approved",
      approvedAt,
    });
  }

  // Immutableコレクション操作
  addTag(tagId: TagId): QuizSummaryParseResult {
    const currentTagIds = this.get("tagIds");
    if (currentTagIds.includes(tagId)) {
      const error: QuizSummaryParseError = {
        kind: "parse",
        issues: [
          {
            path: ["tagIds"],
            code: "custom",
            message: `Tag ${tagId} already exists`,
          },
        ],
        patches: [],
      };
      return err(error);
    }
    return this.update("tagIds", [...currentTagIds, tagId]);
  }

  removeTag(tagId: TagId): QuizSummaryParseResult {
    const currentTagIds = this.get("tagIds");
    const newTagIds = currentTagIds.filter((id) => id !== tagId);
    if (newTagIds.length === currentTagIds.length) {
      const error: QuizSummaryParseError = {
        kind: "parse",
        issues: [
          {
            path: ["tagIds"],
            code: "custom",
            message: `Tag ${tagId} not found`,
          },
        ],
        patches: [],
      };
      return err(error);
    }
    return this.update("tagIds", newTagIds);
  }
```

### Draft Class実装

```typescript
  /**
   * Draft class - DraftBase継承によるSelf-type pattern
   * パッチシステムと統合された統一ParseErrorインターフェース
   */
  static Draft = class extends DraftBase<
    QuizSummary,
    typeof QuizSummarySchema
  > {
    constructor() {
      super(parseQuizSummary);
    }

    // DraftBaseから継承される共通メソッド:
    // - commit(): QuizSummaryParseResult
    // - validate(): QuizSummaryParseResult
    // - getParseError(): QuizSummaryParseError | null
    // - getIssues(): Issue[]
    // - getPatches(): QuizSummaryPatch[]
    // - applyPatches(patches: QuizSummaryPatch[]): void
    // - update<K>(key: K, value: QuizSummaryInput[K]): void
    // - with(patch: Partial<QuizSummaryInput>): void
    // - get<K>(key: K): QuizSummaryInput[K] | undefined
    // - clearErrors(): void
    // - hasErrors(): boolean
    // - getErrors(path: string): string[]
  };
}
```

---

## テスト実装パターン

**ファイル名**: `{EntityName}.spec.ts`

### 基本構造

```typescript
import { beforeEach, describe, expect, it } from "vitest";
import { QuizId, QuizSummary, TagId } from "./QuizSummary";

describe("QuizSummary", () => {
  const validTagIds = [TagId.parse("tag-1"), TagId.parse("tag-2")] as const;

  const validQuizData = {
    id: "quiz-1",
    question: "What is TypeScript?",
    answerType: "single_choice",
    solutionId: "solution-1",
    explanation: "TypeScript is a typed superset of JavaScript",
    tagIds: validTagIds,
    status: "pending_approval",
    creatorId: "creator-1",
    createdAt: "2023-12-01T10:00:00.000Z",
    approvedAt: undefined,
  } as const;

  describe("Brand Types", () => {
    describe("QuizId validation", () => {
      it.each([
        ["valid alphanumeric", "quiz-1", true],
        ["valid with numbers", "quiz123", true],
        ["empty string", "", false],
        ["null value", null, false],
        ["undefined value", undefined, false],
      ])("should handle %s: %s", (_desc, input, isValid) => {
        const result = QuizId.safeParse(input);
        expect(result.success).toBe(isValid);
      });
    });
  });

  describe("Entity Creation", () => {
    it("should create valid quiz from complete data", () => {
      const result = QuizSummary.from(validQuizData);
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const quiz = result.value;
        expect(quiz.get("question")).toBe("What is TypeScript?");
        expect(quiz.get("status")).toBe("pending_approval");
      }
    });

    it("should suggest patches for invalid data", () => {
      const invalidData = {
        ...validQuizData,
        question: "  ", // 空白のみ
        answerType: "single", // typo
      };

      const result = QuizSummary.from(invalidData);
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        const { issues, patches } = result.error;
        expect(issues).toHaveLength(2);
        expect(patches).toHaveLength(2);
      }
    });
  });

  describe("Business Logic", () => {
    let quiz: QuizSummary;

    beforeEach(() => {
      const result = QuizSummary.from(validQuizData);
      expect(result.isOk()).toBe(true);
      quiz = result._unsafeUnwrap();
    });

    it("should approve quiz correctly", () => {
      const approvedResult = quiz.approve("2023-12-02T10:00:00.000Z");
      expect(approvedResult.isOk()).toBe(true);

      if (approvedResult.isOk()) {
        const approvedQuiz = approvedResult.value;
        expect(approvedQuiz.get("status")).toBe("approved");
        expect(approvedQuiz.get("approvedAt")).toBe("2023-12-02T10:00:00.000Z");
      }
    });

    it("should prevent approval of non-pending quiz", () => {
      const approvedResult = quiz.approve("2023-12-02T10:00:00.000Z");
      expect(approvedResult.isOk()).toBe(true);

      const reApprovalResult = approvedResult._unsafeUnwrap().approve("2023-12-03T10:00:00.000Z");
      expect(reApprovalResult.isErr()).toBe(true);
    });
  });

  describe("Draft Usage", () => {
    it("should work with Draft pattern", () => {
      const draft = new QuizSummary.Draft();
      draft.update("question", "Draft question");
      draft.with({
        answerType: "boolean",
        solutionId: "sol-123",
        id: "quiz-draft",
        creatorId: "creator-draft",
        status: "pending_approval",
        createdAt: "2023-12-01T10:00:00.000Z",
      });

      expect(draft.hasErrors()).toBe(false);

      const entityResult = draft.commit();
      expect(entityResult.isOk()).toBe(true);
    });
  });
});
```

---

## 実装チェックリスト

### Schema File

- [ ] Brand型定義（ランタイムスキーマとして）
- [ ] Transform型でnull/undefinedハンドリング
- [ ] `.strict()` + `.superRefine()` でビジネスルール
- [ ] Data/Input型の適切なエクスポート

### Patches File

- [ ] 型エイリアスとユーティリティ再エクスポート
- [ ] フィールド別サジェスト関数（trim, enum修正, array処理等）
- [ ] 効率的な集約サジェスト関数

### Entity File

- [ ] EntityBase継承とSelf-type pattern
- [ ] parseQuizSummary関数実装
- [ ] 包括的な型・ユーティリティ再エクスポート
- [ ] ビジネスロジックメソッド
- [ ] DraftBase継承のDraftクラス

### Test File

- [ ] Brand型の包括的テスト
- [ ] Entity作成・バリデーションテスト
- [ ] ビジネスロジックテスト
- [ ] Draftパターンテスト
- [ ] Patchシステムテスト

---

## 使用例

### 基本的な使用パターン

```typescript
// Entity作成
const quizResult = QuizSummary.from({
  id: "quiz-123",
  question: "What is TypeScript?",
  answerType: "single_choice",
  solutionId: "solution-456",
  tagIds: [TagId.parse("programming"), TagId.parse("typescript")],
  status: "pending_approval",
  creatorId: "user-789",
  createdAt: "2023-12-01T10:00:00.000Z",
});

if (quizResult.isOk()) {
  const quiz = quizResult.value;

  // データ取得
  const question = quiz.get("question");
  const tags = quiz.get("tagIds");

  // 単一フィールド更新
  const updated = quiz.update("question", "Updated question");

  // 複数フィールド更新
  const withPatch = quiz.with({
    question: "New question",
    explanation: "New explanation"
  });

  // ビジネスロジック
  const approved = quiz.approve("2023-12-02T10:00:00.000Z");
  const canUpdate = quiz.canBeUpdated();
} else {
  // エラーハンドリングとパッチ適用
  const { issues, patches } = quizResult.error;
  console.log("Validation issues:", issues);

  // 自動修正候補を適用してリトライ
  const recoveredInput = applyQuizSummaryPatches(originalInput, patches);
  const retryResult = QuizSummary.from(recoveredInput);
}
```

### Draft使用例

```typescript
// Draft作成・編集
const draft = new QuizSummary.Draft();
draft.update("question", "Draft question");
draft.with({
  answerType: "boolean",
  solutionId: "sol-123",
  id: "quiz-draft",
  creatorId: "creator-draft",
  status: "pending_approval",
  createdAt: "2023-12-01T10:00:00.000Z",
});

// リアルタイム検証
if (draft.hasErrors()) {
  const questionErrors = draft.getErrors("question");
  console.log("Question errors:", questionErrors);
}

// パッチ適用によるエラー修正
const patches = draft.getPatches();
if (patches.length > 0) {
  draft.applyPatches(patches);
}

// Entity変換
const entityResult = draft.commit();
if (entityResult.isOk()) {
  const quiz = entityResult.value;
  // 通常のEntity使用...
}
```

---

このガイドラインに従うことで、QuizSummaryと同等の品質・型安全性・保守性を持つドメインエンティティを確実に実装できます。
