# é›†ç´„è¨­è¨ˆã‚¬ã‚¤ãƒ‰

## ç›®çš„

- ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã¨2æ®µéšã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¸­å¿ƒã¨ã—ã¦é›†ç´„ã¨é›†ç´„ãƒ«ãƒ¼ãƒˆã‚’è¨­è¨ˆã—ã€Event Sourcingãƒ»CQRSãƒ»Sagaãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã®çµ±åˆã‚’è€ƒæ…®ã—ãŸç–çµåˆã§æ‹¡å¼µæ€§ã®é«˜ã„ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’å®Ÿç¾ã›ã‚ˆ

## éµå®ˆäº‹é …

- **ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•çµ±åˆ**: ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¸­å¿ƒã¨ã—ãŸé›†ç´„è¨­è¨ˆã¨å¢ƒç•Œæ±ºå®šã‚’è¡Œãˆ
- **2æ®µéšã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ**: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å†…ã§ã®ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²ã¨æˆåŠŸå¾Œã®ç™ºè¡Œã‚’åˆ†é›¢ã›ã‚ˆ
- **æ•´åˆæ€§å¢ƒç•Œã®æ˜ç¢ºåŒ–**: é›†ç´„å†…ã¯å¼·æ•´åˆæ€§ã€é›†ç´„é–“ã¯çµæœæ•´åˆæ€§ã‚’åŸå‰‡ã¨ã›ã‚ˆ
- **çµ±åˆè¨­è¨ˆæ–¹é‡**: Event Sourcingãƒ»CQRSãƒ»Sagaãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã®æ•´åˆæ€§ã‚’ä¿ã£ãŸè¨­è¨ˆæ–¹é‡ã‚’æä¾›ã›ã‚ˆ

## ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆå‡ºåŠ›å…ˆ

### åŸºæœ¬æ–¹é‡

é›†ç´„è¨­è¨ˆæˆæœç‰©ã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ã®ä¸­æ ¸ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨ã—ã¦ã€`docs/project/ddd-design/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«é…ç½®ã—ã€ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®å®Ÿè£…æŒ‡é‡ã‚’æä¾›ã™ã‚‹ã€‚

### å‡ºåŠ›å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```text
docs/project/ddd-design/2.08_aggregate-design/
â”œâ”€â”€ aggregate-design.md                    # é›†ç´„è¨­è¨ˆï¼ˆãƒ¡ã‚¤ãƒ³ï¼‰
â”œâ”€â”€ aggregates/                           # å€‹åˆ¥é›†ç´„è©³ç´°è¨­è¨ˆ
â”‚   â”œâ”€â”€ Quiz.aggregate.md                 # Quizé›†ç´„è©³ç´°ä»•æ§˜
â”‚   â”œâ”€â”€ LearningSession.aggregate.md      # LearningSessioné›†ç´„è©³ç´°ä»•æ§˜
â”‚   â”œâ”€â”€ Identity.aggregate.md             # Identityé›†ç´„è©³ç´°ä»•æ§˜
â”‚   â””â”€â”€ README.md                         # é›†ç´„ä¸€è¦§ãƒ»é–¢ä¿‚å›³
â”œâ”€â”€ event-sourcing/                      # ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°è¨­è¨ˆ
â”‚   â”œâ”€â”€ event-streams.md                  # ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ è¨­è¨ˆ
â”‚   â”œâ”€â”€ event-schema-evolution.md         # ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ã‚­ãƒ¼ãƒé€²åŒ–æˆ¦ç•¥
â”‚   â””â”€â”€ snapshots-strategy.md             # ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæˆ¦ç•¥
â”œâ”€â”€ cqrs-integration/                    # CQRSçµ±åˆè¨­è¨ˆ
â”‚   â”œâ”€â”€ command-side-design.md            # ã‚³ãƒãƒ³ãƒ‰å´è¨­è¨ˆ
â”‚   â”œâ”€â”€ query-side-projections.md         # ã‚¯ã‚¨ãƒªå´ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³
â”‚   â””â”€â”€ projection-update-strategies.md   # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ›´æ–°æˆ¦ç•¥
â””â”€â”€ saga-coordination/                   # Sagaå”èª¿è¨­è¨ˆ
    â”œâ”€â”€ process-managers.md               # ãƒ—ãƒ­ã‚»ã‚¹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼è¨­è¨ˆ
    â”œâ”€â”€ saga-state-machines.md            # SagaçŠ¶æ…‹ãƒã‚·ãƒ³è¨­è¨ˆ
    â””â”€â”€ compensation-strategies.md        # è£œå„Ÿãƒ­ã‚¸ãƒƒã‚¯æˆ¦ç•¥
```

**ãƒ•ã‚¡ã‚¤ãƒ«å‘½åè¦å‰‡**:

- **é›†ç´„è©³ç´°**: `{AggregateName}.aggregate.md`
- **ã‚¤ãƒ™ãƒ³ãƒˆè¨­è¨ˆ**: `{event-category}-events.md`
- **PascalCaseä½¿ç”¨**: é›†ç´„åãƒ»ã‚¤ãƒ™ãƒ³ãƒˆåã¯PascalCaseã§çµ±ä¸€

## é›†ç´„è¨­è¨ˆã®æ‰‹é †

### 1. ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆä¸­å¿ƒã®é›†ç´„è¨­è¨ˆ

#### 1.1 Event Stormingãƒ™ãƒ¼ã‚¹é›†ç´„æŠ½å‡º

**å‚ç…§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: [Event Stormingãƒ¯ãƒ¼ã‚¯ã‚·ãƒ§ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰](./03.04_event-storming-workshop-guide.md)ã€[ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆä¸€è¦§ä½œæˆã‚¬ã‚¤ãƒ‰](./03.10_domain-events-catalog-guide.md)ã®æˆæœç‰©

**å¿…é ˆå®Ÿæ–½é …ç›®**:

- Big Picture Event Stormingã§ç‰¹å®šã•ã‚ŒãŸãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰é›†ç´„å€™è£œã‚’æŠ½å‡º
- ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œè€…ã¨ã‚¤ãƒ™ãƒ³ãƒˆå†…å®¹ã‹ã‚‰é›†ç´„å¢ƒç•Œã‚’ç‰¹å®š
- ãƒ“ã‚¸ãƒã‚¹ãƒ—ãƒ­ã‚»ã‚¹ã«ãŠã‘ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‹ã‚‰é›†ç´„é–“é–¢ä¿‚ã‚’åˆ†æ

**ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆåˆ†æãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**:

```markdown
# ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆä¸­å¿ƒã®é›†ç´„è¨­è¨ˆ

## Domain Event Analysis for Aggregate Design

| Domain Event | Event Producer | Aggregate Candidate | Business Trigger | Data Payload | Downstream Impact |
|--------------|----------------|-------------------|------------------|--------------|------------------|
| {EventName} | {Producer entity} | {Aggregate name} | {What caused event} | {Event data} | {Who cares about this event} |

## Event-to-Aggregate Mapping

| Aggregate Name | Published Events | Subscribed Events | Event Publishing Pattern | Consistency Requirements |
|----------------|------------------|-------------------|-------------------------|-------------------------|
| {AggregateName} | {Event list} | {Subscribed events} | Immediate/Deferred/Batch | Strong/Eventual |

## Event Flow Analysis

| Business Process | Event Sequence | Aggregate Interactions | Saga Coordination Needed | Compensation Logic |
|------------------|----------------|----------------------|-------------------------|-------------------|
| {Process name} | {Event1 â†’ Event2 â†’ Event3} | {Aggregate interactions} | Yes/No | {Rollback strategy} |
```

#### 1.2 ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å¢ƒç•Œæ±ºå®š

**å¢ƒç•Œæ±ºå®šåˆ†æãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**:

```markdown
# ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å¢ƒç•Œæ±ºå®š

## Event Cohesion Analysis

| Event Group | Cohesion Level | Aggregate Boundary Indicator | Split Rationale | Merge Rationale |
|-------------|----------------|----------------------------|-----------------|-----------------|
| {Event group} | High/Medium/Low | Strong/Weak | {Why to split} | {Why to merge} |

## Event Publishing Consistency Requirements

| Event Type | Publishing Timing | Consistency Guarantee | Transaction Scope | Failure Handling |
|------------|------------------|----------------------|-------------------|------------------|
| {Event type} | Immediate/Deferred/Async | Strong/Eventual | Local/Distributed | Retry/DLQ/Manual |
```

### 2. é›†ç´„ãƒ«ãƒ¼ãƒˆã¨ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œè¨­è¨ˆ

#### 2.1 2æ®µéšã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œãƒ‘ã‚¿ãƒ¼ãƒ³

**2æ®µéšç™ºè¡Œãƒ‘ã‚¿ãƒ¼ãƒ³è¨­è¨ˆ**:

```markdown
# Two-Phase Event Publication Design

## Phase 1: Event Registration (Within Transaction)

| Aggregate Method | Business Operation | Events Registered | Registration Timing | Validation Required |
|------------------|-------------------|-------------------|--------------------|--------------------|
| {method name} | {Operation description} | {Event list} | Before/After state change | {Validation logic} |

## Phase 2: Event Publishing (After Transaction Success)

| Registered Event | Publishing Strategy | Delivery Guarantee | Error Handling | Monitoring |
|------------------|-------------------|-------------------|----------------|------------|
| {Event name} | Immediate/Batch/Scheduled | At-least-once/Exactly-once | Retry/DLQ | {Metrics tracked} |
```

#### 2.2 é›†ç´„ãƒ«ãƒ¼ãƒˆå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

**å®Ÿè£…ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**:

```typescript
// Event Registration Interface
interface AggregateRoot {
  getUncommittedEvents(): DomainEvent[];
  markEventsAsCommitted(): void;
  registerEvent(event: DomainEvent): void;
}

// Event-Sourced Aggregate Root Base Class
abstract class EventSourcedAggregateRoot implements AggregateRoot {
  private uncommittedEvents: DomainEvent[] = [];
  protected version: number = 0;
  
  protected registerEvent(event: DomainEvent): void {
    this.uncommittedEvents.push(event);
  }
  
  getUncommittedEvents(): DomainEvent[] {
    return [...this.uncommittedEvents];
  }
  
  markEventsAsCommitted(): void {
    this.uncommittedEvents = [];
  }
  
  // Load from event stream
  static fromHistory<T extends EventSourcedAggregateRoot>(
    events: DomainEvent[], 
    constructor: new () => T
  ): T {
    const aggregate = new constructor();
    events.forEach(event => {
      aggregate.applyEvent(event);
      aggregate.version++;
    });
    aggregate.markEventsAsCommitted();
    return aggregate;
  }
  
  // Execute business command
  protected executeCommand(command: Command): void {
    // Business logic validation
    this.validateCommand(command);
    
    // Generate domain event
    const event = this.createEvent(command);
    
    // Apply event to change state
    this.applyEvent(event);
    
    // Register for publishing
    this.registerEvent(event);
    
    this.version++;
  }
  
  protected abstract applyEvent(event: DomainEvent): void;
  protected abstract validateCommand(command: Command): void;
  protected abstract createEvent(command: Command): DomainEvent;
}
```

### 3. Event Sourcingçµ±åˆè¨­è¨ˆ

#### 3.1 ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ è¨­è¨ˆ

**ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ è¨­è¨ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**:

```markdown
# Event Sourcing Integration Design

## Event Stream Design

| Aggregate Type | Event Categories | Stream Naming | Snapshot Strategy | Replay Performance |
|----------------|------------------|---------------|-------------------|-------------------|
| {Aggregate name} | {Event categories} | {Stream naming convention} | {When to snapshot} | {Replay optimization} |

## Event Schema Evolution

| Event Type | Schema Version | Backward Compatibility | Upcasting Strategy | Migration Path |
|------------|----------------|----------------------|-------------------|----------------|
| {Event name} | {Version} | Compatible/Breaking | {How to upcast} | {Migration steps} |

## Event Store Integration

| Aspect | Design Decision | Implementation | Performance | Consistency |
|--------|----------------|----------------|-------------|-------------|
| Event Persistence | Append-only/Versioned | {Database choice} | {Write performance} | {ACID guarantees} |
| Event Retrieval | Stream-based/Snapshot+Events | {Query strategy} | {Read performance} | {Read consistency} |
| Concurrent Access | Optimistic/Pessimistic | {Concurrency control} | {Throughput impact} | {Conflict resolution} |
```

#### 3.2 ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæˆ¦ç•¥

**ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆè¨­è¨ˆ**:

- **é »åº¦æ±ºå®š**: ã‚¤ãƒ™ãƒ³ãƒˆæ•°ãƒ»æ™‚é–“ãƒ»ãƒ“ã‚¸ãƒã‚¹é‡è¦æ€§ã«ã‚ˆã‚‹åŸºæº–
- **ãƒ‡ãƒ¼ã‚¿æ§‹é€ **: é›†ç´„çŠ¶æ…‹ã®åŠ¹ç‡çš„ãªã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
- **äº’æ›æ€§**: ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆå½¢å¼ã®å¾Œæ–¹äº’æ›æ€§ç¢ºä¿
- **å¾©æ—§æˆ¦ç•¥**: ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ+å¾Œç¶šã‚¤ãƒ™ãƒ³ãƒˆã«ã‚ˆã‚‹é«˜é€Ÿå¾©æ—§

### 4. CQRSçµ±åˆã¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³

#### 4.1 ã‚³ãƒãƒ³ãƒ‰ãƒ»ã‚¯ã‚¨ãƒªåˆ†é›¢è¨­è¨ˆ

**CQRSçµ±åˆè¨­è¨ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**:

```markdown
# CQRS Integration Design

## Command Side (Aggregate Focus)

| Command | Aggregate Method | Business Validation | Events Generated | State Changes | Performance |
|---------|------------------|-------------------|------------------|---------------|-------------|
| {Command name} | {Method name} | {Validation logic} | {Event list} | {State changes} | {Write performance} |

## Query Side (Projection Focus)

| Query | Data Source | Projection Model | Update Trigger | Consistency Level | Performance |
|-------|-------------|-----------------|----------------|-------------------|-------------|
| {Query name} | {Event stream/Read model} | {Data structure} | {Event that triggers update} | Strong/Eventual | {Read performance} |

## Projection Update Strategy

| Projection Type | Update Pattern | Data Consistency | Error Handling | Rebuild Strategy |
|-----------------|----------------|------------------|----------------|------------------|
| {Projection name} | Real-time/Batch/Scheduled | Strong/Eventual | Retry/Skip/Alert | Full/Incremental |
```

#### 4.2 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**:

```typescript
// Projection Handler Base Class
abstract class ProjectionHandler {
  constructor(protected projectionStore: ProjectionStore) {}
  
  abstract handle(event: DomainEvent): Promise<void>;
  
  protected async upsertProjection(
    projectionName: string, 
    id: string, 
    data: any
  ): Promise<void> {
    await this.projectionStore.upsert(projectionName, id, data);
  }
}

// Specific Projection Handler Example
class QuizListProjectionHandler extends ProjectionHandler {
  @EventHandler(QuizPublishedEvent)
  async handleQuizPublished(event: QuizPublishedEvent): Promise<void> {
    const projection = {
      quizId: event.quizId,
      title: event.title,
      description: event.description,
      publishedAt: event.timestamp,
      questionCount: event.questionCount
    };

    await this.upsertProjection('quiz-list', event.quizId, projection);
  }
}
```

### 5. Sagaçµ±åˆã¨ãƒ—ãƒ­ã‚»ã‚¹ç®¡ç†

#### 5.1 Sagaãƒ‘ã‚¿ãƒ¼ãƒ³çµ±åˆè¨­è¨ˆ

**Sagaè¨­è¨ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**:

```markdown
# Saga Pattern Integration

## Process Manager Design

| Saga Name | Triggering Event | Participating Aggregates | Compensation Logic | State Management |
|-----------|------------------|------------------------|--------------------|------------------|
| {Saga name} | {Initial event} | {Aggregate list} | {Rollback steps} | {How state tracked} |

## Saga State Machine

| Current State | Incoming Event | Next State | Actions | Compensation Actions |
|---------------|----------------|------------|---------|---------------------|
| {State} | {Event} | {Next state} | {Commands to send} | {Rollback commands} |
```

#### 5.2 Sagaå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³

**Sagaãƒ—ãƒ­ã‚»ã‚¹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**:

```typescript
// Saga Process Manager Base Class
abstract class SagaProcessManager {
  protected sagaId: string;
  protected currentState: SagaState;
  protected correlationId: string;
  protected sagaData: any = {};
  
  // Handle domain event
  handle(event: DomainEvent): SagaCommand[] {
    const nextState = this.getNextState(this.currentState, event);
    const commands = this.getCommandsForTransition(
      this.currentState, 
      nextState, 
      event
    );
    
    this.currentState = nextState;
    
    if (this.isCompleted()) {
      this.markAsCompleted();
    }
    
    return commands;
  }
  
  // Compensation logic
  compensate(reason: CompensationReason): SagaCommand[] {
    return this.getCompensationCommands(this.currentState, reason);
  }
  
  protected abstract getNextState(
    current: SagaState, 
    event: DomainEvent
  ): SagaState;
  
  protected abstract getCommandsForTransition(
    from: SagaState, 
    to: SagaState, 
    event: DomainEvent
  ): SagaCommand[];
  
  protected abstract getCompensationCommands(
    state: SagaState, 
    reason: CompensationReason
  ): SagaCommand[];
}
```

## å®Œäº†åˆ¤å®šåŸºæº–

### å¿…é ˆè¦ä»¶

- **ã‚¤ãƒ™ãƒ³ãƒˆä¸­å¿ƒè¨­è¨ˆã®å®Œäº†**: ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰è‡ªç„¶ã«å°å‡ºã•ã‚ŒãŸé›†ç´„å¢ƒç•ŒãŒè¨­è¨ˆã•ã‚Œã¦ã„ã‚‹
- **2æ®µéšã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œã®å®Ÿè£…**: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å®‰å…¨ãªã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¨­è¨ˆã•ã‚Œã¦ã„ã‚‹
- **Event Sourcingå¯¾å¿œ**: ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ»ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆãƒ»ã‚¹ã‚­ãƒ¼ãƒé€²åŒ–ãŒè¨­è¨ˆã•ã‚Œã¦ã„ã‚‹
- **CQRSçµ±åˆ**: ã‚³ãƒãƒ³ãƒ‰å´ã¨ã‚¯ã‚¨ãƒªå´ã®è²¬ä»»åˆ†é›¢ã¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æˆ¦ç•¥ãŒæ˜ç¢º

### å“è³ªè¦ä»¶

- **ç–çµåˆæ€§**: ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã«ã‚ˆã‚‹é›†ç´„é–“ã®ç–çµåˆãŒå®Ÿç¾ã•ã‚Œã¦ã„ã‚‹
- **æ‹¡å¼µæ€§**: æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã‚„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã®è¿½åŠ ãŒå®¹æ˜“
- **ç›£æŸ»è¨¼è·¡**: ã™ã¹ã¦ã®å¤‰æ›´ãŒã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦è¨˜éŒ²ã•ã‚Œå®Œå…¨ãªç›£æŸ»è¨¼è·¡ã‚’æä¾›
- **å¾©æ—§æ€§**: ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰ã®çŠ¶æ…‹å¾©æ—§ãŒå¯èƒ½

### æ–‡æ›¸å“è³ªè¦ä»¶

- **è¡¨å½¢å¼ã®æ´»ç”¨**: é›†ç´„åˆ†æãƒ»ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒƒãƒ”ãƒ³ã‚°ãƒ»CQRSè¨­è¨ˆãŒè¡¨å½¢å¼ã§æ•´ç†ã•ã‚Œã¦ã„ã‚‹
- **å›³è¡¨ã«ã‚ˆã‚‹å¯è¦–åŒ–**: Mermaidã«ã‚ˆã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãƒ•ãƒ­ãƒ¼ãƒ»SagaçŠ¶æ…‹ãƒã‚·ãƒ³ãŒå¯è¦–åŒ–ã•ã‚Œã¦ã„ã‚‹
- **è¨­è¨ˆä»•æ§˜ã®æä¾›**: é›†ç´„ãƒ«ãƒ¼ãƒˆãƒ»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ãƒ»Sagaçµ±åˆã®è¨­è¨ˆä»•æ§˜ãŒè¨˜è¼‰
- **çµ±åˆæŒ‡é‡ã®æ˜ç¢ºåŒ–**: Event Sourcingãƒ»CQRSãƒ»Sagaã¨ã®çµ±åˆæ–¹é‡ãŒå…·ä½“çš„ã«è¨˜è¼‰

## å®Œäº†å¾Œã®å¿…é ˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³

1. **ç›´ã¡ã«**ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã€Œé›†ç´„è¨­è¨ˆãƒ»ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä¾é ¼ã™ã‚‹
2. **ADRä½œæˆ**: ä»¥ä¸‹ã®é‡è¦ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ±ºå®šã«ã¤ã„ã¦ã€å¿…ãšADRã‚’ä½œæˆã™ã‚‹ï¼š
   - **ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¡ç”¨æ±ºå®š**: ãªãœã‚¤ãƒ™ãƒ³ãƒˆä¸­å¿ƒè¨­è¨ˆã‚’é¸æŠã—ãŸã‹ã®æ ¹æ‹ 
   - **2æ®µéšã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œãƒ‘ã‚¿ãƒ¼ãƒ³æ±ºå®š**: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å®‰å…¨æ€§ç¢ºä¿ã®è¨­è¨ˆé¸æŠç†ç”±
   - **Event Sourcingçµ±åˆæ±ºå®š**: ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆã‚¢ãƒ»ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæˆ¦ç•¥ã®é¸æŠæ ¹æ‹ 
   - **CQRSçµ±åˆãƒ¬ãƒ™ãƒ«æ±ºå®š**: ã‚³ãƒãƒ³ãƒ‰ãƒ»ã‚¯ã‚¨ãƒªåˆ†é›¢ã®é©ç”¨ç¯„å›²æ±ºå®šç†ç”±
3. **ADRä½œæˆæ‰‹é †**:
   - å„ADRã¯ã€ŒProposedã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§ä½œæˆ
   - ADRã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ`docs/project/adr/README.md`ï¼‰ã¸ã®è¿½åŠ 
   - DDDè¨­è¨ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆï¼ˆ`docs/project/ddd-design/README.md`ï¼‰ã‹ã‚‰ã®ãƒªãƒ³ã‚¯è¿½åŠ 
4. **æ¬¡å·¥ç¨‹ã®åˆ¤æ–­**ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å§”ã­ã‚‹ï¼š
   - é€šå¸¸ãƒ•ãƒ­ãƒ¼ï¼šã€Œå¢ƒç•Œã¥ã‘ã‚‰ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå®šç¾©ã€ã€ŒAPIè¨­è¨ˆã€ã«é€²ã‚€
   - ä¸¦è¡Œãƒ•ãƒ­ãƒ¼ï¼šã€ŒDBè¨­è¨ˆã€ã§ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆã‚¢ãƒ»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã‚¹ãƒˆã‚¢è¨­è¨ˆ
   - æˆ»ã‚Šãƒ•ãƒ­ãƒ¼ï¼šé›†ç´„è¨­è¨ˆã«åŸºã¥ããƒ‰ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒ“ã‚¹ãƒ»ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£é–¢ä¿‚ã®è¦‹ç›´ã—
5. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ˜ç¤ºçš„ãªæ‰¿èªã‚’å¾—ã¦ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸå·¥ç¨‹ã«é€²ã‚€

## å‚è€ƒï¼šã‚¢ãƒ—ãƒ­ãƒ¼ãƒé¸æŠç†ç”±

### ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•çµ±åˆå‹ã®æ¡ç”¨ç†ç”±

**é¸æŠæ ¹æ‹ **:

- âœ… **ã‚¤ãƒ™ãƒ³ãƒˆä¸­å¿ƒè¨­è¨ˆ**: ãƒ“ã‚¸ãƒã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰è‡ªç„¶ã«é›†ç´„å¢ƒç•ŒãŒå°å‡ºã•ã‚Œã‚‹
- âœ… **ç–çµåˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**: ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã«ã‚ˆã‚‹é›†ç´„é–“ã®ç–çµåˆå®Ÿç¾
- âœ… **æ‹¡å¼µæ€§**: æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã‚„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã®è¿½åŠ ãŒå®¹æ˜“
- âœ… **ç›£æŸ»è¨¼è·¡**: ã™ã¹ã¦ã®å¤‰æ›´ãŒã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦è¨˜éŒ²ã•ã‚Œå®Œå…¨ãªç›£æŸ»è¨¼è·¡

**é©ç”¨å ´é¢**:

- **ã‚¤ãƒ™ãƒ³ãƒˆé‡è¦**: ãƒ“ã‚¸ãƒã‚¹ã‚¤ãƒ™ãƒ³ãƒˆãŒé‡è¦ã§ç›£æŸ»è¨¼è·¡ãŒå¿…è¦
- **é«˜ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£**: å¤§é‡ã®ãƒ‡ãƒ¼ã‚¿ã¨é«˜ã„åŒæ™‚å®Ÿè¡Œæ€§ãŒè¦æ±‚ã•ã‚Œã‚‹
- **ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹**: è¤‡æ•°ã®ã‚µãƒ¼ãƒ“ã‚¹é–“ã§ã®ç–çµåˆãŒé‡è¦
- **è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼**: è¤‡æ•°ã‚¹ãƒ†ãƒƒãƒ—ã®ãƒ“ã‚¸ãƒã‚¹ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚ã‚‹

ã“ã®é¸æŠã«ã‚ˆã‚Šã€ç¾ä»£çš„ãªã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨çµ±åˆã•ã‚ŒãŸé«˜åº¦ãªé›†ç´„è¨­è¨ˆãŒå®Ÿç¾ã•ã‚Œã‚‹ã€‚

## ğŸ“š è©³ç´°å®Ÿè£…ã‚¬ã‚¤ãƒ‰ï¼šã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•é›†ç´„è¨­è¨ˆ

### Event Sourcingçµ±åˆè¨­è¨ˆ

#### QuizSessioné›†ç´„ã®Event Sourcingå®Ÿè£…

```typescript
// Event Sourced QuizSession Aggregate
class QuizSession extends EventSourcedAggregateRoot {
  private sessionId: SessionId;
  private userId: UserId;
  private quizId: QuizId;
  private answers: Map<QuestionId, Answer> = new Map();
  private startTime: Date;
  private endTime?: Date;
  private status: SessionStatus;

  // Command handler with event registration
  startSession(command: StartSessionCommand): void {
    // Business validation
    if (this.status !== SessionStatus.NotStarted) {
      throw new Error("Session already started");
    }

    // Update state
    this.status = SessionStatus.Active;
    this.startTime = new Date();

    // Register domain event
    this.registerEvent(new SessionStartedEvent({
      sessionId: this.sessionId,
      userId: this.userId,
      quizId: this.quizId,
      startTime: this.startTime
    }));
  }

  submitAnswer(command: SubmitAnswerCommand): void {
    // Business validation
    this.validateAnswerSubmission(command);

    // Update state
    this.answers.set(command.questionId, command.answer);

    // Register domain event
    this.registerEvent(new AnswerSubmittedEvent({
      sessionId: this.sessionId,
      questionId: command.questionId,
      answer: command.answer,
      timestamp: new Date()
    }));

    // Check for completion
    if (this.isAllQuestionsAnswered()) {
      this.completeSession();
    }
  }

  private completeSession(): void {
    this.status = SessionStatus.Completed;
    this.endTime = new Date();

    // Calculate score
    const score = this.calculateScore();

    // Register completion event
    this.registerEvent(new SessionCompletedEvent({
      sessionId: this.sessionId,
      userId: this.userId,
      quizId: this.quizId,
      score: score,
      completionTime: this.endTime!,
      answers: Array.from(this.answers.entries())
    }));
  }

  // Load from event stream
  static fromHistory(events: DomainEvent[]): QuizSession {
    const aggregate = new QuizSession();
    events.forEach(event => {
      aggregate.applyEvent(event);
      aggregate.version++;
    });
    aggregate.markEventsAsCommitted();
    return aggregate;
  }

  protected applyEvent(event: DomainEvent): void {
    switch (event.constructor.name) {
      case 'SessionStartedEvent':
        this.applySessionStartedEvent(event as SessionStartedEvent);
        break;
      case 'AnswerSubmittedEvent':
        this.applyAnswerSubmittedEvent(event as AnswerSubmittedEvent);
        break;
      case 'SessionCompletedEvent':
        this.applySessionCompletedEvent(event as SessionCompletedEvent);
        break;
    }
  }
}
```

### CQRS ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¨­è¨ˆ

#### Quiz List Projection Handler

```typescript
// Quiz List Projection Handler
class QuizListProjectionHandler {
  constructor(private projectionStore: ProjectionStore) {}

  @EventHandler(QuizPublishedEvent)
  async handleQuizPublished(event: QuizPublishedEvent): Promise<void> {
    const projection = {
      quizId: event.quizId,
      title: event.title,
      description: event.description,
      category: event.category,
      difficulty: event.difficulty,
      questionCount: event.questionCount,
      publishedAt: event.timestamp,
      rating: 0, // Will be updated by rating events
      completionCount: 0 // Will be updated by completion events
    };

    await this.projectionStore.upsert('quiz-list', event.quizId, projection);
  }

  @EventHandler(SessionCompletedEvent)
  async handleSessionCompleted(event: SessionCompletedEvent): Promise<void> {
    // Update completion count and average rating
    await this.projectionStore.increment('quiz-list', event.quizId, {
      completionCount: 1,
      totalScore: event.score
    });
  }
}
```

### Sagaè¨­è¨ˆï¼šQuiz Completion Process

#### QuizCompletionSagaå®Ÿè£…

```typescript
class QuizCompletionSaga extends SagaProcessManager {
  handle(event: DomainEvent): SagaCommand[] {
    switch (this.currentState) {
      case SagaState.Started:
        if (event instanceof SessionCompletedEvent) {
          this.currentState = SagaState.UpdatingStats;
          return [new UpdateStatisticsCommand({
            userId: event.userId,
            quizId: event.quizId,
            score: event.score,
            completionTime: event.completionTime
          })];
        }
        break;

      case SagaState.UpdatingStats:
        if (event instanceof StatisticsUpdatedEvent) {
          this.currentState = SagaState.CheckingAchievements;
          return [new CheckAchievementsCommand({
            userId: event.userId,
            quizId: event.quizId,
            totalScore: event.totalScore,
            completionCount: event.completionCount
          })];
        }
        break;

      case SagaState.CheckingAchievements:
        if (event instanceof AchievementCheckedEvent) {
          if (event.certificateEligible) {
            this.currentState = SagaState.IssuingCertificate;
            return [new IssueCertificateCommand({
              userId: event.userId,
              quizId: event.quizId,
              achievementLevel: event.achievementLevel
            })];
          } else {
            this.currentState = SagaState.Completed;
            return [];
          }
        }
        break;

      case SagaState.IssuingCertificate:
        if (event instanceof CertificateIssuedEvent) {
          this.currentState = SagaState.Completed;
          return [];
        }
        break;
    }

    return [];
  }

  compensate(reason: CompensationReason): SagaCommand[] {
    const compensationCommands: SagaCommand[] = [];

    // Reverse actions based on current state
    switch (this.currentState) {
      case SagaState.IssuingCertificate:
        compensationCommands.push(new RevokeCertificateCommand({
          userId: this.correlationId,
          certificateId: this.sagaData.certificateId
        }));
        // Fall through to previous state compensation

      case SagaState.CheckingAchievements:
        compensationCommands.push(new RemoveAchievementCommand({
          userId: this.correlationId,
          achievementId: this.sagaData.achievementId
        }));
        // Fall through to previous state compensation

      case SagaState.UpdatingStats:
        compensationCommands.push(new RemoveStatisticsCommand({
          userId: this.correlationId,
          sessionId: this.sagaData.sessionId
        }));
        break;
    }

    this.currentState = SagaState.Compensating;
    return compensationCommands;
  }
}
```

### Event Store çµ±åˆè¨­è¨ˆ

#### Event Stream Design for Quiz Application

```markdown
# Event Stream Design

| Aggregate Type | Event Categories | Stream Naming | Snapshot Strategy | Replay Performance |
|----------------|------------------|---------------|-------------------|-------------------|
| Quiz | Content, Lifecycle, Publishing | quiz-{quizId} | Every 10 events or before publish | Questions cached separately |
| QuizSession | Session, Answers, Completion | session-{sessionId} | On completion only | Answer events batched |
| User | Identity, Profile, Preferences | user-{userId} | Every 50 events | Profile cached in memory |

# Event Schema Evolution

| Event Type | Schema Version | Backward Compatibility | Upcasting Strategy | Migration Path |
|------------|----------------|----------------------|-------------------|----------------|
| QuizCreated | v1.0 â†’ v1.1 | Compatible (added optional fields) | None required | No migration |
| AnswerSubmitted | v1.0 â†’ v2.0 | Breaking (changed answer format) | Convert old format to new | Background migration |
| SessionCompleted | v1.0 â†’ v1.2 | Compatible (added score breakdown) | Populate new fields with defaults | Lazy migration |
```

### Two-Phase Event Publication Pattern

#### å®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è©³ç´°

```typescript
// Event Registration Interface
interface AggregateRoot {
  getUncommittedEvents(): DomainEvent[];
  markEventsAsCommitted(): void;
  registerEvent(event: DomainEvent): void;
}

// Implementation Template
abstract class EventSourcedAggregateRoot implements AggregateRoot {
  private uncommittedEvents: DomainEvent[] = [];
  
  protected registerEvent(event: DomainEvent): void {
    this.uncommittedEvents.push(event);
  }
  
  getUncommittedEvents(): DomainEvent[] {
    return [...this.uncommittedEvents];
  }
  
  markEventsAsCommitted(): void {
    this.uncommittedEvents = [];
  }
}

// Application Service with Two-Phase Pattern
class QuizApplicationService {
  async executeCommand(command: Command): Promise<void> {
    const transaction = await this.unitOfWork.begin();
    
    try {
      // Phase 1: Execute business logic and register events
      const aggregate = await this.repository.findById(command.aggregateId);
      aggregate.execute(command);
      
      // Save aggregate state (events are registered but not published)
      await this.repository.save(aggregate);
      await transaction.commit();
      
      // Phase 2: Publish events after successful transaction
      const uncommittedEvents = aggregate.getUncommittedEvents();
      for (const event of uncommittedEvents) {
        await this.eventBus.publish(event);
      }
      
      aggregate.markEventsAsCommitted();
      
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
}
```

### é«˜åº¦ãªã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³

#### Event Sourced Repository Implementation

```typescript
class EventSourcedQuizRepository {
  constructor(
    private eventStore: EventStore,
    private snapshotStore: SnapshotStore
  ) {}

  async findById(quizId: QuizId): Promise<Quiz> {
    // Try to load from snapshot first
    const snapshot = await this.snapshotStore.getLatest(quizId);
    const fromVersion = snapshot ? snapshot.version : 0;
    
    // Load events since snapshot
    const events = await this.eventStore.getEvents(
      quizId, 
      fromVersion
    );
    
    // Reconstruct aggregate
    let quiz: Quiz;
    if (snapshot) {
      quiz = Quiz.fromSnapshot(snapshot);
    } else {
      quiz = new Quiz();
    }
    
    // Apply events to rebuild state
    events.forEach(event => quiz.applyEvent(event));
    
    return quiz;
  }

  async save(quiz: Quiz): Promise<void> {
    const uncommittedEvents = quiz.getUncommittedEvents();
    
    if (uncommittedEvents.length === 0) {
      return; // No changes to save
    }
    
    // Save events atomically
    await this.eventStore.saveEvents(
      quiz.id,
      uncommittedEvents,
      quiz.version
    );
    
    // Create snapshot if needed
    if (this.shouldCreateSnapshot(quiz)) {
      const snapshot = quiz.createSnapshot();
      await this.snapshotStore.save(snapshot);
    }
  }
  
  private shouldCreateSnapshot(quiz: Quiz): boolean {
    return quiz.version % 10 === 0; // Snapshot every 10 events
  }
}
```

ã“ã®å®Ÿè£…ã‚¬ã‚¤ãƒ‰ã«ã‚ˆã‚Šã€ç†è«–çš„ãªé›†ç´„è¨­è¨ˆã‹ã‚‰å®Ÿè·µçš„ãªã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å®Ÿè£…ã¾ã§ã€å®Œå…¨ãªé–‹ç™ºæŒ‡é‡ãŒæä¾›ã•ã‚Œã‚‹ã€‚
