# 集約設計ガイド

## 目的

- ドメインイベントと2段階イベント発行パターンを中心として集約と集約ルートを設計し、Event Sourcing・CQRS・Sagaパターンとの統合を考慮した疎結合で拡張性の高いイベント駆動アーキテクチャを実現せよ

## 遵守事項

- **イベント駆動統合**: ドメインイベントを中心とした集約設計と境界決定を行え
- **2段階イベント発行**: トランザクション内でのイベント登録と成功後の発行を分離せよ
- **整合性境界の明確化**: 集約内は強整合性、集約間は結果整合性を原則とせよ
- **統合設計方針**: Event Sourcing・CQRS・Sagaパターンとの整合性を保った設計方針を提供せよ

## アウトプット出力先

### 基本方針

集約設計成果物は、ドメインモデルの中核アーキテクチャとして、`docs/project/ddd-design/` ディレクトリに配置し、イベント駆動アーキテクチャの実装指針を提供する。

### 出力先ディレクトリ構造

```text
docs/project/ddd-design/2.08_aggregate-design/
├── aggregate-design.md                    # 集約設計（メイン）
├── aggregates/                           # 個別集約詳細設計
│   ├── Quiz.aggregate.md                 # Quiz集約詳細仕様
│   ├── LearningSession.aggregate.md      # LearningSession集約詳細仕様
│   ├── Identity.aggregate.md             # Identity集約詳細仕様
│   └── README.md                         # 集約一覧・関係図
├── event-sourcing/                      # イベントソーシング設計
│   ├── event-streams.md                  # イベントストリーム設計
│   ├── event-schema-evolution.md         # イベントスキーマ進化戦略
│   └── snapshots-strategy.md             # スナップショット戦略
├── cqrs-integration/                    # CQRS統合設計
│   ├── command-side-design.md            # コマンド側設計
│   ├── query-side-projections.md         # クエリ側プロジェクション
│   └── projection-update-strategies.md   # プロジェクション更新戦略
└── saga-coordination/                   # Saga協調設計
    ├── process-managers.md               # プロセスマネージャー設計
    ├── saga-state-machines.md            # Saga状態マシン設計
    └── compensation-strategies.md        # 補償ロジック戦略
```

**ファイル命名規則**:

- **集約詳細**: `{AggregateName}.aggregate.md`
- **イベント設計**: `{event-category}-events.md`
- **PascalCase使用**: 集約名・イベント名はPascalCaseで統一

## 集約設計の手順

### 1. ドメインイベント中心の集約設計

#### 1.1 Event Stormingベース集約抽出

**参照ドキュメント**: [Event Stormingワークショップガイド](./03.04_event-storming-workshop-guide.md)、[ドメインイベント一覧作成ガイド](./03.10_domain-events-catalog-guide.md)の成果物

**必須実施項目**:

- Big Picture Event Stormingで特定されたドメインイベントから集約候補を抽出
- イベント発行者とイベント内容から集約境界を特定
- ビジネスプロセスにおけるイベントシーケンスから集約間関係を分析

**ドメインイベント分析テンプレート**:

```markdown
# ドメインイベント中心の集約設計

## Domain Event Analysis for Aggregate Design

| Domain Event | Event Producer | Aggregate Candidate | Business Trigger | Data Payload | Downstream Impact |
|--------------|----------------|-------------------|------------------|--------------|------------------|
| {EventName} | {Producer entity} | {Aggregate name} | {What caused event} | {Event data} | {Who cares about this event} |

## Event-to-Aggregate Mapping

| Aggregate Name | Published Events | Subscribed Events | Event Publishing Pattern | Consistency Requirements |
|----------------|------------------|-------------------|-------------------------|-------------------------|
| {AggregateName} | {Event list} | {Subscribed events} | Immediate/Deferred/Batch | Strong/Eventual |

## Event Flow Analysis

| Business Process | Event Sequence | Aggregate Interactions | Saga Coordination Needed | Compensation Logic |
|------------------|----------------|----------------------|-------------------------|-------------------|
| {Process name} | {Event1 → Event2 → Event3} | {Aggregate interactions} | Yes/No | {Rollback strategy} |
```

#### 1.2 イベント駆動境界決定

**境界決定分析テンプレート**:

```markdown
# イベント駆動境界決定

## Event Cohesion Analysis

| Event Group | Cohesion Level | Aggregate Boundary Indicator | Split Rationale | Merge Rationale |
|-------------|----------------|----------------------------|-----------------|-----------------|
| {Event group} | High/Medium/Low | Strong/Weak | {Why to split} | {Why to merge} |

## Event Publishing Consistency Requirements

| Event Type | Publishing Timing | Consistency Guarantee | Transaction Scope | Failure Handling |
|------------|------------------|----------------------|-------------------|------------------|
| {Event type} | Immediate/Deferred/Async | Strong/Eventual | Local/Distributed | Retry/DLQ/Manual |
```

### 2. 集約ルートとイベント発行設計

#### 2.1 2段階イベント発行パターン

**2段階発行パターン設計**:

```markdown
# Two-Phase Event Publication Design

## Phase 1: Event Registration (Within Transaction)

| Aggregate Method | Business Operation | Events Registered | Registration Timing | Validation Required |
|------------------|-------------------|-------------------|--------------------|--------------------|
| {method name} | {Operation description} | {Event list} | Before/After state change | {Validation logic} |

## Phase 2: Event Publishing (After Transaction Success)

| Registered Event | Publishing Strategy | Delivery Guarantee | Error Handling | Monitoring |
|------------------|-------------------|-------------------|----------------|------------|
| {Event name} | Immediate/Batch/Scheduled | At-least-once/Exactly-once | Retry/DLQ | {Metrics tracked} |
```

#### 2.2 集約ルート実装パターン

**実装テンプレート**:

```typescript
// Event Registration Interface
interface AggregateRoot {
  getUncommittedEvents(): DomainEvent[];
  markEventsAsCommitted(): void;
  registerEvent(event: DomainEvent): void;
}

// Event-Sourced Aggregate Root Base Class
abstract class EventSourcedAggregateRoot implements AggregateRoot {
  private uncommittedEvents: DomainEvent[] = [];
  protected version: number = 0;
  
  protected registerEvent(event: DomainEvent): void {
    this.uncommittedEvents.push(event);
  }
  
  getUncommittedEvents(): DomainEvent[] {
    return [...this.uncommittedEvents];
  }
  
  markEventsAsCommitted(): void {
    this.uncommittedEvents = [];
  }
  
  // Load from event stream
  static fromHistory<T extends EventSourcedAggregateRoot>(
    events: DomainEvent[], 
    constructor: new () => T
  ): T {
    const aggregate = new constructor();
    events.forEach(event => {
      aggregate.applyEvent(event);
      aggregate.version++;
    });
    aggregate.markEventsAsCommitted();
    return aggregate;
  }
  
  // Execute business command
  protected executeCommand(command: Command): void {
    // Business logic validation
    this.validateCommand(command);
    
    // Generate domain event
    const event = this.createEvent(command);
    
    // Apply event to change state
    this.applyEvent(event);
    
    // Register for publishing
    this.registerEvent(event);
    
    this.version++;
  }
  
  protected abstract applyEvent(event: DomainEvent): void;
  protected abstract validateCommand(command: Command): void;
  protected abstract createEvent(command: Command): DomainEvent;
}
```

### 3. Event Sourcing統合設計

#### 3.1 イベントストリーム設計

**イベントストリーム設計テンプレート**:

```markdown
# Event Sourcing Integration Design

## Event Stream Design

| Aggregate Type | Event Categories | Stream Naming | Snapshot Strategy | Replay Performance |
|----------------|------------------|---------------|-------------------|-------------------|
| {Aggregate name} | {Event categories} | {Stream naming convention} | {When to snapshot} | {Replay optimization} |

## Event Schema Evolution

| Event Type | Schema Version | Backward Compatibility | Upcasting Strategy | Migration Path |
|------------|----------------|----------------------|-------------------|----------------|
| {Event name} | {Version} | Compatible/Breaking | {How to upcast} | {Migration steps} |

## Event Store Integration

| Aspect | Design Decision | Implementation | Performance | Consistency |
|--------|----------------|----------------|-------------|-------------|
| Event Persistence | Append-only/Versioned | {Database choice} | {Write performance} | {ACID guarantees} |
| Event Retrieval | Stream-based/Snapshot+Events | {Query strategy} | {Read performance} | {Read consistency} |
| Concurrent Access | Optimistic/Pessimistic | {Concurrency control} | {Throughput impact} | {Conflict resolution} |
```

#### 3.2 スナップショット戦略

**スナップショット設計**:

- **頻度決定**: イベント数・時間・ビジネス重要性による基準
- **データ構造**: 集約状態の効率的なシリアライゼーション
- **互換性**: スナップショット形式の後方互換性確保
- **復旧戦略**: スナップショット+後続イベントによる高速復旧

### 4. CQRS統合とプロジェクション

#### 4.1 コマンド・クエリ分離設計

**CQRS統合設計テンプレート**:

```markdown
# CQRS Integration Design

## Command Side (Aggregate Focus)

| Command | Aggregate Method | Business Validation | Events Generated | State Changes | Performance |
|---------|------------------|-------------------|------------------|---------------|-------------|
| {Command name} | {Method name} | {Validation logic} | {Event list} | {State changes} | {Write performance} |

## Query Side (Projection Focus)

| Query | Data Source | Projection Model | Update Trigger | Consistency Level | Performance |
|-------|-------------|-----------------|----------------|-------------------|-------------|
| {Query name} | {Event stream/Read model} | {Data structure} | {Event that triggers update} | Strong/Eventual | {Read performance} |

## Projection Update Strategy

| Projection Type | Update Pattern | Data Consistency | Error Handling | Rebuild Strategy |
|-----------------|----------------|------------------|----------------|------------------|
| {Projection name} | Real-time/Batch/Scheduled | Strong/Eventual | Retry/Skip/Alert | Full/Incremental |
```

#### 4.2 プロジェクション実装パターン

**プロジェクションハンドラーテンプレート**:

```typescript
// Projection Handler Base Class
abstract class ProjectionHandler {
  constructor(protected projectionStore: ProjectionStore) {}
  
  abstract handle(event: DomainEvent): Promise<void>;
  
  protected async upsertProjection(
    projectionName: string, 
    id: string, 
    data: any
  ): Promise<void> {
    await this.projectionStore.upsert(projectionName, id, data);
  }
}

// Specific Projection Handler Example
class QuizListProjectionHandler extends ProjectionHandler {
  @EventHandler(QuizPublishedEvent)
  async handleQuizPublished(event: QuizPublishedEvent): Promise<void> {
    const projection = {
      quizId: event.quizId,
      title: event.title,
      description: event.description,
      publishedAt: event.timestamp,
      questionCount: event.questionCount
    };

    await this.upsertProjection('quiz-list', event.quizId, projection);
  }
}
```

### 5. Saga統合とプロセス管理

#### 5.1 Sagaパターン統合設計

**Saga設計テンプレート**:

```markdown
# Saga Pattern Integration

## Process Manager Design

| Saga Name | Triggering Event | Participating Aggregates | Compensation Logic | State Management |
|-----------|------------------|------------------------|--------------------|------------------|
| {Saga name} | {Initial event} | {Aggregate list} | {Rollback steps} | {How state tracked} |

## Saga State Machine

| Current State | Incoming Event | Next State | Actions | Compensation Actions |
|---------------|----------------|------------|---------|---------------------|
| {State} | {Event} | {Next state} | {Commands to send} | {Rollback commands} |
```

#### 5.2 Saga実装パターン

**Sagaプロセスマネージャーテンプレート**:

```typescript
// Saga Process Manager Base Class
abstract class SagaProcessManager {
  protected sagaId: string;
  protected currentState: SagaState;
  protected correlationId: string;
  protected sagaData: any = {};
  
  // Handle domain event
  handle(event: DomainEvent): SagaCommand[] {
    const nextState = this.getNextState(this.currentState, event);
    const commands = this.getCommandsForTransition(
      this.currentState, 
      nextState, 
      event
    );
    
    this.currentState = nextState;
    
    if (this.isCompleted()) {
      this.markAsCompleted();
    }
    
    return commands;
  }
  
  // Compensation logic
  compensate(reason: CompensationReason): SagaCommand[] {
    return this.getCompensationCommands(this.currentState, reason);
  }
  
  protected abstract getNextState(
    current: SagaState, 
    event: DomainEvent
  ): SagaState;
  
  protected abstract getCommandsForTransition(
    from: SagaState, 
    to: SagaState, 
    event: DomainEvent
  ): SagaCommand[];
  
  protected abstract getCompensationCommands(
    state: SagaState, 
    reason: CompensationReason
  ): SagaCommand[];
}
```

## 完了判定基準

### 必須要件

- **イベント中心設計の完了**: ドメインイベントから自然に導出された集約境界が設計されている
- **2段階イベント発行の実装**: トランザクション安全なイベント発行パターンが設計されている
- **Event Sourcing対応**: イベントストリーム・スナップショット・スキーマ進化が設計されている
- **CQRS統合**: コマンド側とクエリ側の責任分離とプロジェクション戦略が明確

### 品質要件

- **疎結合性**: イベント駆動による集約間の疎結合が実現されている
- **拡張性**: 新しいイベントハンドラやプロジェクションの追加が容易
- **監査証跡**: すべての変更がイベントとして記録され完全な監査証跡を提供
- **復旧性**: イベントストリームからの状態復旧が可能

### 文書品質要件

- **表形式の活用**: 集約分析・イベントマッピング・CQRS設計が表形式で整理されている
- **図表による可視化**: Mermaidによるイベントフロー・Saga状態マシンが可視化されている
- **設計仕様の提供**: 集約ルート・プロジェクション・Saga統合の設計仕様が記載
- **統合指針の明確化**: Event Sourcing・CQRS・Sagaとの統合方針が具体的に記載

## 完了後の必須アクション

1. **直ちに**ユーザーに「集約設計・イベント駆動アーキテクチャ」のレビューを依頼する
2. **ADR作成**: 以下の重要なアーキテクチャ決定について、必ずADRを作成する：
   - **イベント駆動アーキテクチャ採用決定**: なぜイベント中心設計を選択したかの根拠
   - **2段階イベント発行パターン決定**: トランザクション安全性確保の設計選択理由
   - **Event Sourcing統合決定**: イベントストア・スナップショット戦略の選択根拠
   - **CQRS統合レベル決定**: コマンド・クエリ分離の適用範囲決定理由
3. **ADR作成手順**:
   - 各ADRは「Proposed」ステータスで作成
   - ADRインデックス（`docs/project/adr/README.md`）への追加
   - DDD設計ドキュメント（`docs/project/ddd-design/README.md`）からのリンク追加
4. **次工程の判断**をユーザーに委ねる：
   - 通常フロー：「境界づけられたコンテキスト定義」「API設計」に進む
   - 並行フロー：「DB設計」でイベントストア・プロジェクションストア設計
   - 戻りフロー：集約設計に基づくドメインサービス・エンティティ関係の見直し
5. ユーザーの明示的な承認を得てから指定された工程に進む

## 参考：アプローチ選択理由

### イベント駆動統合型の採用理由

**選択根拠**:

- ✅ **イベント中心設計**: ビジネスイベントから自然に集約境界が導出される
- ✅ **疎結合アーキテクチャ**: イベント駆動による集約間の疎結合実現
- ✅ **拡張性**: 新しいイベントハンドラやプロジェクションの追加が容易
- ✅ **監査証跡**: すべての変更がイベントとして記録され完全な監査証跡

**適用場面**:

- **イベント重要**: ビジネスイベントが重要で監査証跡が必要
- **高スケーラビリティ**: 大量のデータと高い同時実行性が要求される
- **マイクロサービス**: 複数のサービス間での疎結合が重要
- **複雑なワークフロー**: 複数ステップのビジネスプロセスがある

この選択により、現代的なイベント駆動アーキテクチャと統合された高度な集約設計が実現される。

## 📚 詳細実装ガイド：イベント駆動集約設計

### Event Sourcing統合設計

#### QuizSession集約のEvent Sourcing実装

```typescript
// Event Sourced QuizSession Aggregate
class QuizSession extends EventSourcedAggregateRoot {
  private sessionId: SessionId;
  private userId: UserId;
  private quizId: QuizId;
  private answers: Map<QuestionId, Answer> = new Map();
  private startTime: Date;
  private endTime?: Date;
  private status: SessionStatus;

  // Command handler with event registration
  startSession(command: StartSessionCommand): void {
    // Business validation
    if (this.status !== SessionStatus.NotStarted) {
      throw new Error("Session already started");
    }

    // Update state
    this.status = SessionStatus.Active;
    this.startTime = new Date();

    // Register domain event
    this.registerEvent(new SessionStartedEvent({
      sessionId: this.sessionId,
      userId: this.userId,
      quizId: this.quizId,
      startTime: this.startTime
    }));
  }

  submitAnswer(command: SubmitAnswerCommand): void {
    // Business validation
    this.validateAnswerSubmission(command);

    // Update state
    this.answers.set(command.questionId, command.answer);

    // Register domain event
    this.registerEvent(new AnswerSubmittedEvent({
      sessionId: this.sessionId,
      questionId: command.questionId,
      answer: command.answer,
      timestamp: new Date()
    }));

    // Check for completion
    if (this.isAllQuestionsAnswered()) {
      this.completeSession();
    }
  }

  private completeSession(): void {
    this.status = SessionStatus.Completed;
    this.endTime = new Date();

    // Calculate score
    const score = this.calculateScore();

    // Register completion event
    this.registerEvent(new SessionCompletedEvent({
      sessionId: this.sessionId,
      userId: this.userId,
      quizId: this.quizId,
      score: score,
      completionTime: this.endTime!,
      answers: Array.from(this.answers.entries())
    }));
  }

  // Load from event stream
  static fromHistory(events: DomainEvent[]): QuizSession {
    const aggregate = new QuizSession();
    events.forEach(event => {
      aggregate.applyEvent(event);
      aggregate.version++;
    });
    aggregate.markEventsAsCommitted();
    return aggregate;
  }

  protected applyEvent(event: DomainEvent): void {
    switch (event.constructor.name) {
      case 'SessionStartedEvent':
        this.applySessionStartedEvent(event as SessionStartedEvent);
        break;
      case 'AnswerSubmittedEvent':
        this.applyAnswerSubmittedEvent(event as AnswerSubmittedEvent);
        break;
      case 'SessionCompletedEvent':
        this.applySessionCompletedEvent(event as SessionCompletedEvent);
        break;
    }
  }
}
```

### CQRS プロジェクション設計

#### Quiz List Projection Handler

```typescript
// Quiz List Projection Handler
class QuizListProjectionHandler {
  constructor(private projectionStore: ProjectionStore) {}

  @EventHandler(QuizPublishedEvent)
  async handleQuizPublished(event: QuizPublishedEvent): Promise<void> {
    const projection = {
      quizId: event.quizId,
      title: event.title,
      description: event.description,
      category: event.category,
      difficulty: event.difficulty,
      questionCount: event.questionCount,
      publishedAt: event.timestamp,
      rating: 0, // Will be updated by rating events
      completionCount: 0 // Will be updated by completion events
    };

    await this.projectionStore.upsert('quiz-list', event.quizId, projection);
  }

  @EventHandler(SessionCompletedEvent)
  async handleSessionCompleted(event: SessionCompletedEvent): Promise<void> {
    // Update completion count and average rating
    await this.projectionStore.increment('quiz-list', event.quizId, {
      completionCount: 1,
      totalScore: event.score
    });
  }
}
```

### Saga設計：Quiz Completion Process

#### QuizCompletionSaga実装

```typescript
class QuizCompletionSaga extends SagaProcessManager {
  handle(event: DomainEvent): SagaCommand[] {
    switch (this.currentState) {
      case SagaState.Started:
        if (event instanceof SessionCompletedEvent) {
          this.currentState = SagaState.UpdatingStats;
          return [new UpdateStatisticsCommand({
            userId: event.userId,
            quizId: event.quizId,
            score: event.score,
            completionTime: event.completionTime
          })];
        }
        break;

      case SagaState.UpdatingStats:
        if (event instanceof StatisticsUpdatedEvent) {
          this.currentState = SagaState.CheckingAchievements;
          return [new CheckAchievementsCommand({
            userId: event.userId,
            quizId: event.quizId,
            totalScore: event.totalScore,
            completionCount: event.completionCount
          })];
        }
        break;

      case SagaState.CheckingAchievements:
        if (event instanceof AchievementCheckedEvent) {
          if (event.certificateEligible) {
            this.currentState = SagaState.IssuingCertificate;
            return [new IssueCertificateCommand({
              userId: event.userId,
              quizId: event.quizId,
              achievementLevel: event.achievementLevel
            })];
          } else {
            this.currentState = SagaState.Completed;
            return [];
          }
        }
        break;

      case SagaState.IssuingCertificate:
        if (event instanceof CertificateIssuedEvent) {
          this.currentState = SagaState.Completed;
          return [];
        }
        break;
    }

    return [];
  }

  compensate(reason: CompensationReason): SagaCommand[] {
    const compensationCommands: SagaCommand[] = [];

    // Reverse actions based on current state
    switch (this.currentState) {
      case SagaState.IssuingCertificate:
        compensationCommands.push(new RevokeCertificateCommand({
          userId: this.correlationId,
          certificateId: this.sagaData.certificateId
        }));
        // Fall through to previous state compensation

      case SagaState.CheckingAchievements:
        compensationCommands.push(new RemoveAchievementCommand({
          userId: this.correlationId,
          achievementId: this.sagaData.achievementId
        }));
        // Fall through to previous state compensation

      case SagaState.UpdatingStats:
        compensationCommands.push(new RemoveStatisticsCommand({
          userId: this.correlationId,
          sessionId: this.sagaData.sessionId
        }));
        break;
    }

    this.currentState = SagaState.Compensating;
    return compensationCommands;
  }
}
```

### Event Store 統合設計

#### Event Stream Design for Quiz Application

```markdown
# Event Stream Design

| Aggregate Type | Event Categories | Stream Naming | Snapshot Strategy | Replay Performance |
|----------------|------------------|---------------|-------------------|-------------------|
| Quiz | Content, Lifecycle, Publishing | quiz-{quizId} | Every 10 events or before publish | Questions cached separately |
| QuizSession | Session, Answers, Completion | session-{sessionId} | On completion only | Answer events batched |
| User | Identity, Profile, Preferences | user-{userId} | Every 50 events | Profile cached in memory |

# Event Schema Evolution

| Event Type | Schema Version | Backward Compatibility | Upcasting Strategy | Migration Path |
|------------|----------------|----------------------|-------------------|----------------|
| QuizCreated | v1.0 → v1.1 | Compatible (added optional fields) | None required | No migration |
| AnswerSubmitted | v1.0 → v2.0 | Breaking (changed answer format) | Convert old format to new | Background migration |
| SessionCompleted | v1.0 → v1.2 | Compatible (added score breakdown) | Populate new fields with defaults | Lazy migration |
```

### Two-Phase Event Publication Pattern

#### 実装パターンの詳細

```typescript
// Event Registration Interface
interface AggregateRoot {
  getUncommittedEvents(): DomainEvent[];
  markEventsAsCommitted(): void;
  registerEvent(event: DomainEvent): void;
}

// Implementation Template
abstract class EventSourcedAggregateRoot implements AggregateRoot {
  private uncommittedEvents: DomainEvent[] = [];
  
  protected registerEvent(event: DomainEvent): void {
    this.uncommittedEvents.push(event);
  }
  
  getUncommittedEvents(): DomainEvent[] {
    return [...this.uncommittedEvents];
  }
  
  markEventsAsCommitted(): void {
    this.uncommittedEvents = [];
  }
}

// Application Service with Two-Phase Pattern
class QuizApplicationService {
  async executeCommand(command: Command): Promise<void> {
    const transaction = await this.unitOfWork.begin();
    
    try {
      // Phase 1: Execute business logic and register events
      const aggregate = await this.repository.findById(command.aggregateId);
      aggregate.execute(command);
      
      // Save aggregate state (events are registered but not published)
      await this.repository.save(aggregate);
      await transaction.commit();
      
      // Phase 2: Publish events after successful transaction
      const uncommittedEvents = aggregate.getUncommittedEvents();
      for (const event of uncommittedEvents) {
        await this.eventBus.publish(event);
      }
      
      aggregate.markEventsAsCommitted();
      
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
}
```

### 高度なイベント駆動パターン

#### Event Sourced Repository Implementation

```typescript
class EventSourcedQuizRepository {
  constructor(
    private eventStore: EventStore,
    private snapshotStore: SnapshotStore
  ) {}

  async findById(quizId: QuizId): Promise<Quiz> {
    // Try to load from snapshot first
    const snapshot = await this.snapshotStore.getLatest(quizId);
    const fromVersion = snapshot ? snapshot.version : 0;
    
    // Load events since snapshot
    const events = await this.eventStore.getEvents(
      quizId, 
      fromVersion
    );
    
    // Reconstruct aggregate
    let quiz: Quiz;
    if (snapshot) {
      quiz = Quiz.fromSnapshot(snapshot);
    } else {
      quiz = new Quiz();
    }
    
    // Apply events to rebuild state
    events.forEach(event => quiz.applyEvent(event));
    
    return quiz;
  }

  async save(quiz: Quiz): Promise<void> {
    const uncommittedEvents = quiz.getUncommittedEvents();
    
    if (uncommittedEvents.length === 0) {
      return; // No changes to save
    }
    
    // Save events atomically
    await this.eventStore.saveEvents(
      quiz.id,
      uncommittedEvents,
      quiz.version
    );
    
    // Create snapshot if needed
    if (this.shouldCreateSnapshot(quiz)) {
      const snapshot = quiz.createSnapshot();
      await this.snapshotStore.save(snapshot);
    }
  }
  
  private shouldCreateSnapshot(quiz: Quiz): boolean {
    return quiz.version % 10 === 0; // Snapshot every 10 events
  }
}
```

この実装ガイドにより、理論的な集約設計から実践的なイベント駆動アーキテクチャ実装まで、完全な開発指針が提供される。
