# DB設計

## 目的

- DDD設計で定義されたドメインモデルと集約を基に、データ永続化層の詳細設計を行い、ドメインの整合性とパフォーマンスを両立するデータベース設計書を作成するため、エンティティ関係図・テーブル定義・インデックス戦略・制約定義を含む包括的なデータベース設計を実施する

## 遵守事項

- **DDD設計成果物との整合性保持**：集約境界がトランザクション境界と一致することを必須とする
- **ドメインモデルファーストアプローチ**：データベーススキーマはドメインモデルに従属し、ドメインロジックを優先する
- **表形式によるテーブル設計根拠の明文化**：全テーブル・カラム・制約の設計判断を記録する
- **パフォーマンス要件との両立**：ドメイン整合性を保ちつつ、必要なパフォーマンスを実現する
- **移行戦略の明確化**：既存データベースからの移行手順とリスク評価を含める

## アウトプット出力先

### 基本方針

DB設計成果物は、DDD設計で定義された境界づけられたコンテキスト構造に対応させ、後続の実装・運用フェーズで参照しやすい形で整理する。スキーマ定義とマイグレーションスクリプトは実装プロジェクトと連携する。

### 出力先ディレクトリ構造

```text
db-design/
├── overview.md                     # DB設計概要・選定根拠
├── schema-design/                  # スキーマ設計
│   ├── aggregate-mapping.md        # 集約とテーブルマッピング
│   ├── table-definitions.md        # テーブル定義一覧
│   ├── constraints.md              # 制約・トリガー定義
│   └── indexes.md                  # インデックス戦略
├── contexts/                       # 境界づけられたコンテキスト別
│   ├── user-management/            # ユーザー管理DB設計
│   │   ├── tables.sql              # テーブル作成SQL
│   │   ├── indexes.sql             # インデックス作成SQL
│   │   ├── constraints.sql         # 制約作成SQL
│   │   └── sample-data.sql         # サンプルデータ
│   ├── content-management/         # コンテンツ管理DB設計
│   │   ├── tables.sql              # テーブル作成SQL
│   │   ├── indexes.sql             # インデックス作成SQL
│   │   ├── constraints.sql         # 制約作成SQL
│   │   └── sample-data.sql         # サンプルデータ
│   └── shared/                     # 共有テーブル
│       ├── common-tables.sql       # 共通テーブル定義
│       └── sequences.sql           # シーケンス定義
├── migrations/                     # マイグレーション戦略
│   ├── migration-strategy.md       # 移行戦略・手順
│   ├── rollback-plans.md           # ロールバック計画
│   └── data-migration-scripts/     # データ移行スクリプト
├── performance/                    # パフォーマンス設計
│   ├── query-patterns.md           # 想定クエリパターン
│   ├── performance-requirements.md # パフォーマンス要件
│   └── monitoring-strategy.md      # 監視戦略
└── diagrams/
    ├── erd.mmd                     # エンティティ関係図
    ├── aggregate-tables.mmd        # 集約とテーブル関係図
    └── schema-dependencies.mmd     # スキーマ依存関係図
```

### ファイル命名規則

- **SQLファイル**: `{機能名}-{目的}.sql` （例：`user-tables.sql`）
- **設計書**: `{対象}-{種類}.md` （例：`user-management-tables.md`）
- **図表**: `{対象}-{図表種類}.mmd` （例：`user-management-erd.mmd`）

## 完了判定基準

### 必須成果物の作成完了

- [ ] **DB設計概要書**：選定根拠とアーキテクチャ方針が明文化されている
- [ ] **集約-テーブルマッピング表**：DDD集約とDBテーブルの対応が明確である
- [ ] **テーブル定義書**：全テーブル・カラム・制約が詳細に定義されている
- [ ] **インデックス戦略書**：パフォーマンス要件に基づくインデックス設計がある
- [ ] **エンティティ関係図**：テーブル間の関係が視覚的に表現されている
- [ ] **マイグレーション計画**：段階的移行手順とリスク評価がある

### DDD設計との整合性確認

- [ ] **集約境界の反映**：各集約が適切なテーブル境界で表現されている
- [ ] **トランザクション境界の一致**：集約境界とトランザクション境界が一致している
- [ ] **ドメインルールの制約化**：ビジネスルールがDB制約として実装されている
- [ ] **値オブジェクトの永続化**：値オブジェクトが適切にテーブル設計に反映されている

### パフォーマンス・運用性の確保

- [ ] **クエリパフォーマンス検証**：想定クエリパターンでの性能要件達成
- [ ] **スケーラビリティ考慮**：将来の成長に対応可能な設計
- [ ] **バックアップ・リストア戦略**：データ保護とリカバリ手順の明確化
- [ ] **監視・メンテナンス計画**：運用時の監視指標とメンテナンス手順

### 文書品質の確保

- [ ] **設計根拠の明文化**：テーブル・制約・インデックスの選定理由が記録されている
- [ ] **表形式での比較検討**：代替案との比較表が作成されている
- [ ] **Markdownリント適合**：文書フォーマットが統一されている
- [ ] **図表の整合性**：ERDと設計書の内容が一致している

## 完了後

- すべての成果物をリストアップし、ユーザーからのレビューを受ける
- DDD設計チームとAPI設計チームとの整合性確認会議を実施する
- 実装チームに対するDB設計説明会の準備を行う
- パフォーマンステストシナリオの作成準備を開始する

## DB設計の手順

### 1. 前提確認と設計方針決定

#### 1.1 DDD設計成果物の確認

**必須確認項目**:

| 確認項目 | 確認内容 | 対応するDDD成果物 | DB設計への影響 |
|----------|----------|-----------------|---------------|
| **集約定義** | 集約境界と集約ルートの特定 | `aggregates.md` | トランザクション境界、テーブル分割方針 |
| **エンティティ** | IDの種類、ライフサイクル、状態遷移 | `entities.md` | 主キー設計、状態管理テーブル |
| **値オブジェクト** | 不変性、検証ルール、複合型 | `value-objects.md` | 埋め込み or 正規化、制約設計 |
| **ドメインサービス** | 複数集約にまたがるロジック | `domain-services.md` | 結合クエリ、トランザクション設計 |
| **ユビキタス言語** | ドメイン用語とその定義 | `ubiquitous-language.md` | テーブル名、カラム名の命名 |

**成果物**: `schema-design/ddd-mapping-analysis.md`

#### 1.2 データベース技術選定の確認

**前工程（全体技術設計）での選定結果を確認**:

```markdown
| 確認項目 | 設計への影響 | 制約事項 |
|----------|-------------|----------|
| **DB種別** | スキーマ設計アプローチ | PostgreSQL: 高度な制約、MySQL: シンプル設計 |
| **ORMツール** | マッピング戦略 | Entity Framework: Code First、Prisma: Schema First |
| **トランザクション要件** | 分離レベル、ロック戦略 | ACID厳密性 vs パフォーマンス |
| **スケーリング方針** | パーティション、レプリケーション | 読み書き分離、シャーディング |
```

### 2. 集約とテーブルのマッピング設計

#### 2.1 集約境界の分析

**DDD集約ルールのDB設計への適用**:

| DDD原則 | DB設計での実現方法 | 実装パターン | 注意点 |
|---------|------------------|------------|--------|
| **集約境界 = トランザクション境界** | 一つの集約は一つのトランザクションで更新 | 単一集約テーブル、外部キー最小化 | 集約間結合クエリは避ける |
| **集約ルート経由のアクセス** | 集約内エンティティへの直接操作禁止 | 集約ルートテーブルのみ public、他は内部 | アプリケーション層での制約も必要 |
| **IDによる集約間参照** | 他集約は ID でのみ参照 | 外部キー制約最小限、参照整合性は緩和 | 削除時の参照データ処理が複雑 |
| **集約サイズの最小化** | 必要最小限のデータのみ含める | テーブル正規化、不要な JOIN 回避 | 読み取り性能との天秤 |

**成果物**: `schema-design/aggregate-mapping.md`

#### 2.2 集約-テーブルマッピングパターン

**パターン選択の基準**:

```markdown
| マッピングパターン | 適用条件 | 利点 | 欠点 | 実装例 |
|------------------|----------|------|------|--------|
| **1集約1テーブル** | シンプルな集約 | 単純、高性能 | 正規化不足 | User集約 → usersテーブル |
| **1集約複数テーブル** | 複雑な集約 | 正規化維持 | JOIN必要 | Order集約 → orders + order_items |
| **継承マッピング** | 多態性が必要 | オブジェクト指向的 | 複雑性 | Payment → CreditPayment, CashPayment |
| **値オブジェクト埋め込み** | 小さい値オブジェクト | シンプル | カラム数増加 | Address → street, city, zip カラム |
| **値オブジェクト分離** | 大きい値オブジェクト | 正規化 | 結合必要 | ContactInfo → contact_info テーブル |
```

### 3. テーブル設計詳細化

#### 3.1 主キー設計戦略

**IDタイプの選択**:

| IDタイプ | 利点 | 欠点 | 適用場面 | 実装例 |
|----------|------|------|----------|--------|
| **UUID** | グローバル一意、分散対応 | サイズ大、性能劣化 | 分散システム、外部連携 | `id UUID PRIMARY KEY` |
| **Auto Increment** | 高性能、サイズ小 | 分散時衝突、推測可能 | 単一DB、内部用途 | `id BIGINT AUTO_INCREMENT` |
| **Snowflake ID** | 時系列順序、分散対応 | 実装複雑 | 大規模分散、順序重要 | `id BIGINT` |
| **ULID** | 時系列順序、文字列表現 | 新しい技術 | 時系列重要、可読性必要 | `id CHAR(26)` |

#### 3.2 データ型選択基準

**業務要件に基づくデータ型選択**:

```markdown
| 業務データ | 候補データ型 | 選択基準 | 制約考慮 | 例 |
|-----------|-------------|----------|----------|---|
| **金額** | DECIMAL vs INT | 精度要件、計算性能 | 通貨単位、小数点 | `amount DECIMAL(15,2)` |
| **日時** | TIMESTAMP vs DATETIME | タイムゾーン要件 | UTC統一 vs ローカル時間 | `created_at TIMESTAMP` |
| **テキスト** | VARCHAR vs TEXT | 長さ制限、インデックス | 検索要件、文字セット | `description TEXT` |
| **列挙値** | ENUM vs VARCHAR | 変更頻度、拡張性 | マスタテーブル vs 固定値 | `status VARCHAR(20)` |
| **JSON** | JSON vs 正規化 | 構造の固定度 | 検索要件、性能 | `metadata JSON` |
```

#### 3.3 制約設計

**ビジネスルールの制約化**:

| 制約種別 | 目的 | 実装方法 | 例 | 注意点 |
|----------|------|----------|---|--------|
| **NOT NULL** | 必須項目の強制 | `NOT NULL` | `email VARCHAR(255) NOT NULL` | ドメインの必須性と一致 |
| **UNIQUE** | 一意性保証 | `UNIQUE INDEX` | `UNIQUE(email)` | 論理削除時の考慮 |
| **CHECK** | 値の範囲制限 | `CHECK制約` | `CHECK (age >= 0)` | DB依存性、移植性 |
| **FOREIGN KEY** | 参照整合性 | `REFERENCES` | `FOREIGN KEY (user_id)` | 集約間参照は最小限 |
| **TRIGGER** | 複雑なルール | `BEFORE/AFTER` | 監査ログ、計算フィールド | 複雑化、デバッグ困難 |

### 4. インデックス戦略

#### 4.1 クエリパターン分析

**想定されるクエリパターンの整理**:

```markdown
| 機能 | クエリパターン | 頻度 | レスポンス要件 | インデックス候補 |
|------|--------------|------|--------------|----------------|
| **ユーザー検索** | WHERE email = ? | 高 | <100ms | email単一インデックス |
| **記事一覧** | WHERE status = ? ORDER BY created_at DESC | 高 | <200ms | (status, created_at)複合 |
| **タグ検索** | JOIN articles_tags WHERE tag_name = ? | 中 | <500ms | tag_name, 中間テーブル最適化 |
| **管理画面** | WHERE created_at BETWEEN ? AND ? | 低 | <1s | created_at範囲検索 |
| **全文検索** | WHERE content LIKE %?% | 低 | <2s | 全文検索インデックス |
```

#### 4.2 インデックス設計判断

**インデックス作成の判断基準**:

| 判断項目 | 作成する | 作成しない | 判断理由 |
|----------|----------|-----------|----------|
| **WHERE頻度** | 高頻度 | 低頻度 | クエリ実行回数と性能への影響 |
| **データサイズ** | 大量データ | 小量データ | フルスキャンコストとインデックスメンテナンスコスト |
| **選択性** | 高選択性 | 低選択性 | インデックス効果とストレージコスト |
| **更新頻度** | 低更新 | 高更新 | 更新時のインデックスメンテナンスコスト |
| **複合条件** | 複数条件セット | 単一条件のみ | 複合インデックスの効果 |

### 5. パフォーマンス設計

#### 5.1 パフォーマンス要件の定義

**非機能要件の数値化**:

| 指標 | 目標値 | 測定条件 | 対応策 | 監視方法 |
|------|--------|----------|--------|----------|
| **レスポンス時間** | 平均<200ms、95%ile<500ms | 同時100ユーザー | インデックス最適化、クエリチューニング | APM監視 |
| **スループット** | 1000req/s | ピーク時負荷 | 読み書き分離、コネクションプール | メトリクス監視 |
| **データ増加** | 月間1000万レコード | 1年間の成長予測 | パーティション、アーカイブ戦略 | ストレージ監視 |
| **可用性** | 99.9% | 計画停止除く | レプリケーション、フェイルオーバー | ヘルスチェック |

#### 5.2 スケーリング戦略

**データ増加に対する対応策**:

```markdown
| スケーリング手法 | 適用タイミング | 効果 | 実装コスト | 運用コスト |
|----------------|--------------|------|------------|----------|
| **垂直スケーリング** | 初期〜中期 | 簡単、即効性 | 低 | 中（高性能サーバー） |
| **読み書き分離** | 読み取り負荷増加時 | 読み取り性能向上 | 中 | 中（レプリケーション） |
| **パーティション** | テーブルサイズ巨大化 | クエリ性能維持 | 高 | 高（複雑な運用） |
| **シャーディング** | 単一DBの限界時 | 線形スケール可能 | 高 | 高（分散管理） |
```

### 6. 移行戦略

#### 6.1 段階的移行計画

**既存システムからの移行アプローチ**:

| 移行段階 | 対象 | 手法 | リスク | 対策 |
|----------|------|------|--------|------|
| **Phase 1** | 参照系 | 読み取り専用レプリカ | データ不整合 | 定期同期、整合性確認 |
| **Phase 2** | 新機能 | 新DBに直接実装 | 機能分離の複雑化 | API境界の明確化 |
| **Phase 3** | 更新系 | 段階的データ移行 | ダウンタイム、データ損失 | ブルーグリーン、ロールバック計画 |
| **Phase 4** | 全体移行 | 旧システム停止 | 全サービス影響 | 十分な検証、緊急時計画 |

#### 6.2 データ移行スクリプト設計

**移行処理の自動化**:

```markdown
| 移行種別 | 処理方法 | 検証方法 | ロールバック方法 |
|----------|----------|----------|----------------|
| **マスタデータ** | ETLツール | 件数・サム値照合 | バックアップからリストア |
| **トランザクションデータ** | バッチ処理 | サンプリング検証 | 増分バックアップ活用 |
| **バイナリデータ** | ストリーミング | ハッシュ値照合 | オリジナル保持 |
| **設定データ** | 手動移行 | 機能テスト | 設定ファイルバックアップ |
```

### 7. 監視・運用設計

#### 7.1 監視指標の定義

**データベース監視の重要指標**:

| 監視カテゴリ | 指標 | 警告閾値 | 危険閾値 | 対応アクション |
|-------------|------|----------|----------|----------------|
| **性能** | レスポンス時間 | 500ms | 1000ms | スロークエリ分析 |
| **リソース** | CPU使用率 | 70% | 85% | スケールアップ検討 |
| **ストレージ** | ディスク使用率 | 80% | 90% | 容量拡張、アーカイブ |
| **接続** | コネクション数 | 80% | 95% | コネクションプール調整 |
| **エラー** | エラー率 | 1% | 5% | ログ分析、バグ調査 |

#### 7.2 メンテナンス計画

**定期メンテナンス項目**:

```markdown
| メンテナンス種別 | 頻度 | 目的 | 実施内容 | ダウンタイム |
|----------------|------|------|----------|------------|
| **インデックス再構築** | 月次 | 性能維持 | REBUILD INDEX | 最小（オンライン実行） |
| **統計情報更新** | 週次 | クエリ最適化 | UPDATE STATISTICS | なし |
| **ログファイル管理** | 日次 | ディスク容量管理 | ログローテーション | なし |
| **バックアップ検証** | 月次 | リカバリ保証 | リストアテスト | 別環境で実施 |
| **セキュリティパッチ** | 四半期 | セキュリティ維持 | DB更新 | 計画停止（数時間） |
```

## DB設計時の注意点

### DDD設計との整合性維持

- **集約境界を必ず尊重**：データベーススキーマで集約境界を破ることは禁止
- **ドメインロジックのDB移譲禁止**：ビジネスルールをストアドプロシージャに実装しない
- **ユビキタス言語の活用**：テーブル名・カラム名にドメイン用語を使用
- **値オブジェクトの適切な永続化**：検証ルールと不変性を維持

### パフォーマンスとドメインモデルの両立

- **読み取り専用ビューの活用**：複雑な検索要件は集約を破らずにビューで対応
- **CQRS適用の検討**：更新と参照で異なるデータモデルが必要な場合
- **非正規化の慎重適用**：性能要件達成のための非正規化は最小限に

### 将来への拡張性考慮

- **スキーマ進化戦略**：後方互換性を保つマイグレーション設計
- **国際化対応**：多言語・多通貨・タイムゾーン対応
- **監査ログ設計**：コンプライアンス要求への対応

この手順により、DDD設計に基づき、かつ実用的なデータベース設計を段階的に構築できる。
