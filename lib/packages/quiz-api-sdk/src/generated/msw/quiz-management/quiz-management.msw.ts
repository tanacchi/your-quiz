/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * (title)
 * OpenAPI spec version: 0.0.0
 */
import { faker } from "@faker-js/faker";

import { delay, HttpResponse, http } from "msw";
import type { QuizListResponse, QuizWithSolution } from "../title.schemas";
import { AnswerType, MatchingStrategy, QuizStatus } from "../title.schemas";

export const getQuizManagementCreateQuizResponseMock = (
  overrideResponse: Partial<QuizWithSolution> = {},
): QuizWithSolution => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  question: faker.string.alpha({ length: { min: 10, max: 20 } }),
  answerType: faker.helpers.arrayElement(Object.values(AnswerType)),
  solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  explanation: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  status: faker.helpers.arrayElement(Object.values(QuizStatus)),
  creatorId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  createdAt: faker.string.alpha({ length: { min: 10, max: 20 } }),
  approvedAt: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  solution: faker.helpers.arrayElement([
    {
      type: faker.helpers.arrayElement(["boolean"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      value: faker.datatype.boolean(),
    },
    {
      type: faker.helpers.arrayElement(["free_text"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      correctAnswer: faker.string.alpha({ length: { min: 10, max: 20 } }),
      matchingStrategy: faker.helpers.arrayElement(
        Object.values(MatchingStrategy),
      ),
      caseSensitive: faker.datatype.boolean(),
    },
    {
      type: faker.helpers.arrayElement(["single_choice"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      correctChoiceId: faker.string.alpha({ length: { min: 10, max: 20 } }),
      choices: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
        text: faker.string.alpha({ length: { min: 10, max: 20 } }),
        orderIndex: faker.number.int({
          min: undefined,
          max: undefined,
          multipleOf: undefined,
        }),
      })),
    },
    {
      type: faker.helpers.arrayElement(["multiple_choice"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      correctChoiceIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      minCorrectAnswers: faker.number.int({
        min: undefined,
        max: undefined,
        multipleOf: undefined,
      }),
      choices: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
        text: faker.string.alpha({ length: { min: 10, max: 20 } }),
        orderIndex: faker.number.int({
          min: undefined,
          max: undefined,
          multipleOf: undefined,
        }),
      })),
    },
  ]),
  tags: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getQuizManagementListQuizzesResponseMock =
  (): QuizListResponse => ({
    ...{
      items: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        question: faker.string.alpha({ length: { min: 10, max: 20 } }),
        answerType: faker.helpers.arrayElement(Object.values(AnswerType)),
        solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
        explanation: faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          undefined,
        ]),
        status: faker.helpers.arrayElement(Object.values(QuizStatus)),
        creatorId: faker.string.alpha({ length: { min: 10, max: 20 } }),
        createdAt: faker.string.alpha({ length: { min: 10, max: 20 } }),
        approvedAt: faker.helpers.arrayElement([
          faker.string.alpha({ length: { min: 10, max: 20 } }),
          undefined,
        ]),
        solution: faker.helpers.arrayElement([
          {
            type: faker.helpers.arrayElement(["boolean"] as const),
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            value: faker.datatype.boolean(),
          },
          {
            type: faker.helpers.arrayElement(["free_text"] as const),
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            correctAnswer: faker.string.alpha({ length: { min: 10, max: 20 } }),
            matchingStrategy: faker.helpers.arrayElement(
              Object.values(MatchingStrategy),
            ),
            caseSensitive: faker.datatype.boolean(),
          },
          {
            type: faker.helpers.arrayElement(["single_choice"] as const),
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            correctChoiceId: faker.string.alpha({
              length: { min: 10, max: 20 },
            }),
            choices: Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              id: faker.string.alpha({ length: { min: 10, max: 20 } }),
              solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
              text: faker.string.alpha({ length: { min: 10, max: 20 } }),
              orderIndex: faker.number.int({
                min: undefined,
                max: undefined,
                multipleOf: undefined,
              }),
            })),
          },
          {
            type: faker.helpers.arrayElement(["multiple_choice"] as const),
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            correctChoiceIds: Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
            minCorrectAnswers: faker.number.int({
              min: undefined,
              max: undefined,
              multipleOf: undefined,
            }),
            choices: Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1,
            ).map(() => ({
              id: faker.string.alpha({ length: { min: 10, max: 20 } }),
              solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
              text: faker.string.alpha({ length: { min: 10, max: 20 } }),
              orderIndex: faker.number.int({
                min: undefined,
                max: undefined,
                multipleOf: undefined,
              }),
            })),
          },
        ]),
        tags: faker.helpers.arrayElement([
          Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
          undefined,
        ]),
      })),
      totalCount: faker.number.int({
        min: undefined,
        max: undefined,
        multipleOf: undefined,
      }),
      hasMore: faker.datatype.boolean(),
      continuationToken: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
    },
  });

export const getQuizManagementGetQuizResponseMock = (
  overrideResponse: Partial<QuizWithSolution> = {},
): QuizWithSolution => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  question: faker.string.alpha({ length: { min: 10, max: 20 } }),
  answerType: faker.helpers.arrayElement(Object.values(AnswerType)),
  solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  explanation: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  status: faker.helpers.arrayElement(Object.values(QuizStatus)),
  creatorId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  createdAt: faker.string.alpha({ length: { min: 10, max: 20 } }),
  approvedAt: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  solution: faker.helpers.arrayElement([
    {
      type: faker.helpers.arrayElement(["boolean"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      value: faker.datatype.boolean(),
    },
    {
      type: faker.helpers.arrayElement(["free_text"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      correctAnswer: faker.string.alpha({ length: { min: 10, max: 20 } }),
      matchingStrategy: faker.helpers.arrayElement(
        Object.values(MatchingStrategy),
      ),
      caseSensitive: faker.datatype.boolean(),
    },
    {
      type: faker.helpers.arrayElement(["single_choice"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      correctChoiceId: faker.string.alpha({ length: { min: 10, max: 20 } }),
      choices: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
        text: faker.string.alpha({ length: { min: 10, max: 20 } }),
        orderIndex: faker.number.int({
          min: undefined,
          max: undefined,
          multipleOf: undefined,
        }),
      })),
    },
    {
      type: faker.helpers.arrayElement(["multiple_choice"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      correctChoiceIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      minCorrectAnswers: faker.number.int({
        min: undefined,
        max: undefined,
        multipleOf: undefined,
      }),
      choices: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
        text: faker.string.alpha({ length: { min: 10, max: 20 } }),
        orderIndex: faker.number.int({
          min: undefined,
          max: undefined,
          multipleOf: undefined,
        }),
      })),
    },
  ]),
  tags: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getQuizManagementUpdateQuizResponseMock = (
  overrideResponse: Partial<QuizWithSolution> = {},
): QuizWithSolution => ({
  id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  question: faker.string.alpha({ length: { min: 10, max: 20 } }),
  answerType: faker.helpers.arrayElement(Object.values(AnswerType)),
  solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  explanation: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  status: faker.helpers.arrayElement(Object.values(QuizStatus)),
  creatorId: faker.string.alpha({ length: { min: 10, max: 20 } }),
  createdAt: faker.string.alpha({ length: { min: 10, max: 20 } }),
  approvedAt: faker.helpers.arrayElement([
    faker.string.alpha({ length: { min: 10, max: 20 } }),
    undefined,
  ]),
  solution: faker.helpers.arrayElement([
    {
      type: faker.helpers.arrayElement(["boolean"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      value: faker.datatype.boolean(),
    },
    {
      type: faker.helpers.arrayElement(["free_text"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      correctAnswer: faker.string.alpha({ length: { min: 10, max: 20 } }),
      matchingStrategy: faker.helpers.arrayElement(
        Object.values(MatchingStrategy),
      ),
      caseSensitive: faker.datatype.boolean(),
    },
    {
      type: faker.helpers.arrayElement(["single_choice"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      correctChoiceId: faker.string.alpha({ length: { min: 10, max: 20 } }),
      choices: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
        text: faker.string.alpha({ length: { min: 10, max: 20 } }),
        orderIndex: faker.number.int({
          min: undefined,
          max: undefined,
          multipleOf: undefined,
        }),
      })),
    },
    {
      type: faker.helpers.arrayElement(["multiple_choice"] as const),
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      correctChoiceIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      minCorrectAnswers: faker.number.int({
        min: undefined,
        max: undefined,
        multipleOf: undefined,
      }),
      choices: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({
        id: faker.string.alpha({ length: { min: 10, max: 20 } }),
        solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
        text: faker.string.alpha({ length: { min: 10, max: 20 } }),
        orderIndex: faker.number.int({
          min: undefined,
          max: undefined,
          multipleOf: undefined,
        }),
      })),
    },
  ]),
  tags: faker.helpers.arrayElement([
    Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
    undefined,
  ]),
  ...overrideResponse,
});

export const getQuizManagementCreateQuizMockHandler = (
  overrideResponse?:
    | QuizWithSolution
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0],
      ) => Promise<QuizWithSolution> | QuizWithSolution),
) => {
  return http.post("*/api/quiz/v1/manage/quizzes", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getQuizManagementCreateQuizResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getQuizManagementListQuizzesMockHandler = (
  overrideResponse?:
    | QuizListResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<QuizListResponse> | QuizListResponse),
) => {
  return http.get("*/api/quiz/v1/manage/quizzes", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getQuizManagementListQuizzesResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getQuizManagementGetQuizMockHandler = (
  overrideResponse?:
    | QuizWithSolution
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<QuizWithSolution> | QuizWithSolution),
) => {
  return http.get("*/api/quiz/v1/manage/quizzes/:id", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getQuizManagementGetQuizResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getQuizManagementUpdateQuizMockHandler = (
  overrideResponse?:
    | QuizWithSolution
    | ((
        info: Parameters<Parameters<typeof http.put>[1]>[0],
      ) => Promise<QuizWithSolution> | QuizWithSolution),
) => {
  return http.put("*/api/quiz/v1/manage/quizzes/:id", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getQuizManagementUpdateQuizResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};

export const getQuizManagementDeleteQuizMockHandler = (
  overrideResponse?:
    | null
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0],
      ) => Promise<null> | null),
) => {
  return http.delete("*/api/quiz/v1/manage/quizzes/:id", async (info) => {
    await delay(1000);
    if (typeof overrideResponse === "function") {
      await overrideResponse(info);
    }
    return new HttpResponse(null, { status: 204 });
  });
};
export const getQuizManagementMock = () => [
  getQuizManagementCreateQuizMockHandler(),
  getQuizManagementListQuizzesMockHandler(),
  getQuizManagementGetQuizMockHandler(),
  getQuizManagementUpdateQuizMockHandler(),
  getQuizManagementDeleteQuizMockHandler(),
];
