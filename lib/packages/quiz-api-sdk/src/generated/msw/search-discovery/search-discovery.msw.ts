/**
 * Generated by orval v7.11.2 ðŸº
 * Do not edit manually.
 * (title)
 * ã‚¹ãƒžãƒ¼ãƒˆãƒ•ã‚©ãƒ³å‘ã‘ã‚¯ã‚¤ã‚ºã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®API

ã“ã®APIã¯ã€æ•™è‚²ãƒ»å­¦ç¿’æ”¯æ´ã‚’ç›®çš„ã¨ã—ãŸã‚¯ã‚¤ã‚ºã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãŸã‚ã®åŒ…æ‹¬çš„ãªã‚µãƒ¼ãƒ“ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚

## ä¸»è¦æ©Ÿèƒ½
- **ã‚¯ã‚¤ã‚ºç®¡ç†**: ä½œæˆã€æ›´æ–°ã€å‰Šé™¤ã€æ‰¿èªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
- **æ¤œç´¢ãƒ»ç™ºè¦‹**: é«˜åº¦ãªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨ã‚½ãƒ¼ãƒˆæ©Ÿèƒ½
- **å­¦ç¿’æ”¯æ´**: ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºã•ã‚ŒãŸå­¦ç¿’ä½“é¨“
- **ã‚¿ã‚°ã‚·ã‚¹ãƒ†ãƒ **: éšŽå±¤çš„ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„åˆ†é¡ž

## æŠ€è¡“ä»•æ§˜
- **èªè¨¼**: å…¨æ“ä½œã§ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ãŒå¿…è¦
- **ãƒ¬ãƒ¼ãƒˆåˆ¶é™**: APIæ“ä½œã«ã¯é©åˆ‡ãªåˆ¶é™ã‚’è¨­å®š
- **ãƒ‡ãƒ¼ã‚¿å½¢å¼**: JSONå½¢å¼ã§ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚¹
- **æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°**: UTF-8
 * OpenAPI spec version: 0.0.0
 */
import { faker } from "@faker-js/faker";

import { delay, HttpResponse, http } from "msw";
import type { QuizListResponse } from "../title.schemas";
import { AnswerType, MatchingStrategy, QuizStatus } from "../title.schemas";

export const getSearchSearchQuizzesResponseMock = (): QuizListResponse => ({
  ...{
    items: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      id: faker.string.alpha({ length: { min: 10, max: 20 } }),
      question: faker.string.alpha({ length: { min: 10, max: 20 } }),
      answerType: faker.helpers.arrayElement(Object.values(AnswerType)),
      solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
      explanation: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      status: faker.helpers.arrayElement(Object.values(QuizStatus)),
      creatorId: faker.string.alpha({ length: { min: 10, max: 20 } }),
      createdAt: faker.string.alpha({ length: { min: 10, max: 20 } }),
      approvedAt: faker.helpers.arrayElement([
        faker.string.alpha({ length: { min: 10, max: 20 } }),
        undefined,
      ]),
      solution: faker.helpers.arrayElement([
        {
          type: faker.helpers.arrayElement(["boolean"] as const),
          id: faker.string.alpha({ length: { min: 10, max: 20 } }),
          value: faker.datatype.boolean(),
        },
        {
          type: faker.helpers.arrayElement(["free_text"] as const),
          id: faker.string.alpha({ length: { min: 10, max: 20 } }),
          correctAnswer: faker.string.alpha({ length: { min: 10, max: 20 } }),
          matchingStrategy: faker.helpers.arrayElement(
            Object.values(MatchingStrategy),
          ),
          caseSensitive: faker.datatype.boolean(),
        },
        {
          type: faker.helpers.arrayElement(["single_choice"] as const),
          id: faker.string.alpha({ length: { min: 10, max: 20 } }),
          choices: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => ({
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
            text: faker.string.alpha({ length: { min: 10, max: 20 } }),
            orderIndex: faker.number.int({
              min: undefined,
              max: undefined,
              multipleOf: undefined,
            }),
            isCorrect: faker.datatype.boolean(),
          })),
        },
        {
          type: faker.helpers.arrayElement(["multiple_choice"] as const),
          id: faker.string.alpha({ length: { min: 10, max: 20 } }),
          minCorrectAnswers: faker.number.int({
            min: undefined,
            max: undefined,
            multipleOf: undefined,
          }),
          choices: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1,
          ).map(() => ({
            id: faker.string.alpha({ length: { min: 10, max: 20 } }),
            solutionId: faker.string.alpha({ length: { min: 10, max: 20 } }),
            text: faker.string.alpha({ length: { min: 10, max: 20 } }),
            orderIndex: faker.number.int({
              min: undefined,
              max: undefined,
              multipleOf: undefined,
            }),
            isCorrect: faker.datatype.boolean(),
          })),
        },
      ]),
      tags: faker.helpers.arrayElement([
        Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        undefined,
      ]),
    })),
    totalCount: faker.number.int({
      min: undefined,
      max: undefined,
      multipleOf: undefined,
    }),
    hasMore: faker.datatype.boolean(),
    continuationToken: faker.helpers.arrayElement([
      faker.string.alpha({ length: { min: 10, max: 20 } }),
      undefined,
    ]),
  },
});

export const getSearchSearchQuizzesMockHandler = (
  overrideResponse?:
    | QuizListResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0],
      ) => Promise<QuizListResponse> | QuizListResponse),
) => {
  return http.get("*/api/search/v1/quizzes", async (info) => {
    await delay(1000);

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getSearchSearchQuizzesResponseMock(),
      ),
      { status: 200, headers: { "Content-Type": "application/json" } },
    );
  });
};
export const getSearchDiscoveryMock = () => [
  getSearchSearchQuizzesMockHandler(),
];
