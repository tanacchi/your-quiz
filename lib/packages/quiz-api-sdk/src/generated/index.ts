/**
 * Generated by orval v7.11.2 ğŸº
 * Do not edit manually.
 * (title)
 * OpenAPI spec version: 0.0.0
 */
import type {
  CreateQuizRequest,
  NotFoundError,
  PaginationRequest,
  QuizId,
  QuizManagementCreateQuizDefault,
  QuizManagementDeleteQuizDefault,
  QuizManagementListQuizzesParams,
  QuizManagementUpdateQuizDefault,
  SearchSearchQuizzesParams,
  UpdateQuizRequest
} from './schemas';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';

import {
  AnswerType,
  MatchingStrategy,
  QuizStatus
} from './schemas';
import type {
  QuizListResponse,
  QuizWithSolution
} from './schemas';

export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 426 | 428 | 429 | 431 | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes = HTTPStatusCode1xx | HTTPStatusCode2xx | HTTPStatusCode3xx | HTTPStatusCode4xx | HTTPStatusCode5xx;

/**
 * æ–°ã—ã„ã‚¯ã‚¤ã‚ºä½œæˆAPI

## æ©Ÿèƒ½
- **å¤šæ§˜ãªå•é¡Œå½¢å¼å¯¾å¿œ**: çœŸå½å€¤ã€è‡ªç”±è¨˜è¿°ã€å˜æŠã€è¤‡æ•°é¸æŠã®4å½¢å¼ã‚’ã‚µãƒãƒ¼ãƒˆ
- **è‡ªå‹•ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³**: å•é¡Œæ–‡ãƒ»è§£ç­”ãƒ»é¸æŠè‚¢ã®å¦¥å½“æ€§ã‚’è‡ªå‹•æ¤œè¨¼
- **æ‰¿èªå¾…ã¡çŠ¶æ…‹**: ä½œæˆã•ã‚ŒãŸã‚¯ã‚¤ã‚ºã¯æ‰¿èªå¾…ã¡çŠ¶æ…‹ã§ç®¡ç†è€…ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’çµŒã¦å…¬é–‹
- **ã‚¿ã‚°åˆ†é¡**: å­¦ç¿’åˆ†é‡ãƒ»é›£æ˜“åº¦åˆ¥ã®ã‚¿ã‚°ä»˜ã‘ãŒå¯èƒ½

## åˆ¶é™äº‹é …
- å•é¡Œæ–‡ã¯æœ€å¤§500æ–‡å­—
- è§£èª¬ã¯æœ€å¤§1000æ–‡å­—
- ã‚¿ã‚°ã¯æœ€å¤§10å€‹ã¾ã§
- 1æ—¥ã‚ãŸã‚Šã®ä½œæˆä¸Šé™ï¼š50å•ï¼ˆãƒ¬ãƒ¼ãƒˆåˆ¶é™ï¼‰

## ä½œæˆãƒ•ãƒ­ãƒ¼
1. ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡
2. ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
3. pending_approvalçŠ¶æ…‹ã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
4. ç®¡ç†è€…ã«ã‚ˆã‚‹æ‰¿èªå¾…ã¡ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 

## ä½¿ç”¨ä¾‹
- æ•™è‚²ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ä½œæˆ
- è‡ªç¿’ç”¨å•é¡Œé›†ã®æ§‹ç¯‰
- ã‚¹ã‚­ãƒ«ãƒã‚§ãƒƒã‚¯å•é¡Œã®æº–å‚™
 */
export type quizManagementCreateQuizResponse200 = {
  data: QuizWithSolution
  status: 200
}

export type quizManagementCreateQuizResponseDefault = {
  data: QuizManagementCreateQuizDefault
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type quizManagementCreateQuizResponseComposite = quizManagementCreateQuizResponse200 | quizManagementCreateQuizResponseDefault;
    
export type quizManagementCreateQuizResponse = quizManagementCreateQuizResponseComposite & {
  headers: Headers;
}

export const getQuizManagementCreateQuizUrl = () => {


  

  return `/api/quiz/v1/manage/quizzes`
}

export const quizManagementCreateQuiz = async (createQuizRequest: CreateQuizRequest, options?: RequestInit): Promise<quizManagementCreateQuizResponse> => {
  
  const res = await fetch(getQuizManagementCreateQuizUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createQuizRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: quizManagementCreateQuizResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as quizManagementCreateQuizResponse
}



/**
 * ã‚¯ã‚¤ã‚ºä¸€è¦§å–å¾—APIï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒ»ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰

## æ©Ÿèƒ½
- **å¤šå½©ãªãƒ•ã‚£ãƒ«ã‚¿**: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ»ä½œæˆè€…ãƒ»IDæŒ‡å®šã«ã‚ˆã‚‹çµã‚Šè¾¼ã¿
- **åŠ¹ç‡çš„ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³**: ã‚ªãƒ•ã‚»ãƒƒãƒˆãƒ™ãƒ¼ã‚¹ã§ã®åˆ†å‰²å–å¾—
- **ã‚½ãƒ¼ãƒˆæ©Ÿèƒ½**: ä½œæˆæ—¥æ™‚é †ï¼ˆæœ€æ–°é †ï¼‰ã§ã®ä¸¦ã³æ›¿ãˆ
- **æ¨©é™è€ƒæ…®**: ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™ã«å¿œã˜ãŸè¡¨ç¤ºåˆ¶å¾¡

## ãƒ•ã‚£ãƒ«ã‚¿æ©Ÿèƒ½
- **ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¥**: pending_approval, approved, rejected
- **ä½œæˆè€…åˆ¥**: ç‰¹å®šãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½œæˆã‚¯ã‚¤ã‚ºã®ã¿è¡¨ç¤º
- **IDæŒ‡å®š**: è¤‡æ•°ã®ã‚¯ã‚¤ã‚ºIDã‚’æŒ‡å®šã—ã¦ä¸€æ‹¬å–å¾—

## æ¨©é™ã«ã‚ˆã‚‹è¡¨ç¤ºåˆ¶å¾¡
- **ä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼**: æ‰¿èªæ¸ˆã¿ã‚¯ã‚¤ã‚ºã®ã¿è¡¨ç¤º
- **ä½œæˆè€…**: è‡ªèº«ã®ä½œæˆã—ãŸã‚¯ã‚¤ã‚ºï¼ˆå…¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼‰ã‚‚è¡¨ç¤º
- **ç®¡ç†è€…**: å…¨ã¦ã®ã‚¯ã‚¤ã‚ºï¼ˆå…¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼‰ã‚’è¡¨ç¤º

## ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³
- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 20ä»¶/ãƒšãƒ¼ã‚¸
- æœ€å¤§: 100ä»¶/ãƒšãƒ¼ã‚¸
- ã‚ªãƒ•ã‚»ãƒƒãƒˆãƒ™ãƒ¼ã‚¹: skip/limit ãƒ‘ã‚¿ãƒ¼ãƒ³

## ãƒ¬ã‚¹ãƒãƒ³ã‚¹æƒ…å ±
- ã‚¯ã‚¤ã‚ºä¸€è¦§ï¼ˆQuizWithSolutionå½¢å¼ï¼‰
- ç·ä»¶æ•°ï¼ˆãƒ•ã‚£ãƒ«ã‚¿é©ç”¨å¾Œï¼‰
- ç¶šãã®å­˜åœ¨ãƒ•ãƒ©ã‚°
- ç¶™ç¶šãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆå°†æ¥ã®ã‚«ãƒ¼ã‚½ãƒ«ãƒ™ãƒ¼ã‚¹å¯¾å¿œç”¨ï¼‰

## ä½¿ç”¨å ´é¢
- ç®¡ç†ç”»é¢ã§ã®ã‚¯ã‚¤ã‚ºç®¡ç†
- ä½œæˆè€…ãƒã‚¤ãƒšãƒ¼ã‚¸ã§ã®ä½œå“ä¸€è¦§
- æ‰¿èªå¾…ã¡ã‚­ãƒ¥ãƒ¼ã®è¡¨ç¤º
 */
export type quizManagementListQuizzesResponse200 = {
  data: QuizListResponse
  status: 200
}
    
export type quizManagementListQuizzesResponseComposite = quizManagementListQuizzesResponse200;
    
export type quizManagementListQuizzesResponse = quizManagementListQuizzesResponseComposite & {
  headers: Headers;
}

export const getQuizManagementListQuizzesUrl = (params?: QuizManagementListQuizzesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["ids"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => normalizedParams.append(key, v === null ? 'null' : v.toString()));
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/quiz/v1/manage/quizzes?${stringifiedParams}` : `/api/quiz/v1/manage/quizzes`
}

export const quizManagementListQuizzes = async (paginationRequest: PaginationRequest,
    params?: QuizManagementListQuizzesParams, options?: RequestInit): Promise<quizManagementListQuizzesResponse> => {
  
  const res = await fetch(getQuizManagementListQuizzesUrl(params),
  {      
    ...options,
    method: 'GET',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      paginationRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: quizManagementListQuizzesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as quizManagementListQuizzesResponse
}



/**
 * ã‚¯ã‚¤ã‚ºè©³ç´°æƒ…å ±å–å¾—API

## æ©Ÿèƒ½
- **å®Œå…¨ãªå•é¡Œæƒ…å ±**: å•é¡Œæ–‡ã€è§£ç­”ã€è§£èª¬ã€ã‚¿ã‚°ã‚’å«ã‚€å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
- **æ¨©é™åˆ¶å¾¡**: ä½œæˆè€…ã¾ãŸã¯ç®¡ç†è€…ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ï¼ˆæ‰¿èªå‰ã‚¯ã‚¤ã‚ºã®å ´åˆï¼‰
- **è§£ç­”æƒ…å ±ä»˜ã**: QuizWithSolutionå½¢å¼ã§è§£ç­”ã‚‚å«ã‚ã¦è¿”å´

## ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡
- **å…¬é–‹ã‚¯ã‚¤ã‚ºï¼ˆapprovedï¼‰**: å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
- **æ‰¿èªå¾…ã¡ã‚¯ã‚¤ã‚º**: ä½œæˆè€…ãƒ»ç®¡ç†è€…ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
- **å´ä¸‹ã‚¯ã‚¤ã‚º**: ä½œæˆè€…ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½

## ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ 
- åŸºæœ¬ã‚¯ã‚¤ã‚ºæƒ…å ±ï¼ˆidã€å•é¡Œæ–‡ã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã€ä½œæˆæ—¥æ™‚ç­‰ï¼‰
- è§£ç­”æƒ…å ±ï¼ˆå•é¡Œå½¢å¼ã«å¿œã˜ãŸ Solution ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰
- é–¢é€£ã‚¿ã‚°é…åˆ—
- æ‰¿èªæ—¥æ™‚ï¼ˆæ‰¿èªæ¸ˆã¿ã®å ´åˆï¼‰

## ä½¿ç”¨å ´é¢
- ã‚¯ã‚¤ã‚ºç·¨é›†ç”»é¢ã§ã®è©³ç´°è¡¨ç¤º
- ç®¡ç†ç”»é¢ã§ã®æ‰¿èªãƒ¬ãƒ“ãƒ¥ãƒ¼
- ä½œæˆè€…ã«ã‚ˆã‚‹å†…å®¹ç¢ºèª
 */
export type quizManagementGetQuizResponse200 = {
  data: QuizWithSolution
  status: 200
}

export type quizManagementGetQuizResponseDefault = {
  data: NotFoundError
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type quizManagementGetQuizResponseComposite = quizManagementGetQuizResponse200 | quizManagementGetQuizResponseDefault;
    
export type quizManagementGetQuizResponse = quizManagementGetQuizResponseComposite & {
  headers: Headers;
}

export const getQuizManagementGetQuizUrl = (id: QuizId,) => {


  

  return `/api/quiz/v1/manage/quizzes/${id}`
}

export const quizManagementGetQuiz = async (id: QuizId, options?: RequestInit): Promise<quizManagementGetQuizResponse> => {
  
  const res = await fetch(getQuizManagementGetQuizUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: quizManagementGetQuizResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as quizManagementGetQuizResponse
}



/**
 * ã‚¯ã‚¤ã‚ºæƒ…å ±æ›´æ–°API

## æ©Ÿèƒ½
- **éƒ¨åˆ†æ›´æ–°å¯¾å¿œ**: æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã¿ã‚’æ›´æ–°
- **æ¨©é™åˆ¶å¾¡**: ä½œæˆè€…ã®ã¿æ›´æ–°å¯èƒ½
- **æ‰¿èªçŠ¶æ…‹åˆ¶é™**: æ‰¿èªæ¸ˆã¿ã‚¯ã‚¤ã‚ºã¯æ›´æ–°ä¸å¯
- **ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³**: æ›´æ–°å†…å®¹ã®å¦¥å½“æ€§ã‚’è‡ªå‹•æ¤œè¨¼

## æ›´æ–°å¯èƒ½ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
- å•é¡Œæ–‡ï¼ˆquestionï¼‰
- è§£èª¬ï¼ˆexplanationï¼‰
- ã‚¿ã‚°ï¼ˆtagsï¼‰

## æ›´æ–°åˆ¶é™
- **æ‰¿èªæ¸ˆã¿ã‚¯ã‚¤ã‚º**: æ›´æ–°ä¸å¯ï¼ˆapprovedçŠ¶æ…‹ï¼‰
- **ä»–è€…ä½œæˆã‚¯ã‚¤ã‚º**: æ›´æ–°ä¸å¯ï¼ˆä½œæˆè€…ä»¥å¤–ï¼‰
- **è§£ç­”éƒ¨åˆ†**: ä½œæˆå¾Œã¯å¤‰æ›´ä¸å¯ï¼ˆæ•´åˆæ€§ä¿æŒã®ãŸã‚ï¼‰

## æ›´æ–°å¾Œã®å‹•ä½œ
- æ›´æ–°ã•ã‚ŒãŸã‚¯ã‚¤ã‚ºã¯æ‰¿èªå¾…ã¡çŠ¶æ…‹ã‚’ç¶­æŒ
- ç®¡ç†è€…ã«å†ãƒ¬ãƒ“ãƒ¥ãƒ¼é€šçŸ¥
- æ›´æ–°å±¥æ­´ã®è¨˜éŒ²

## ä½¿ç”¨å ´é¢
- èª¤å­—è„±å­—ã®ä¿®æ­£
- è§£èª¬ã®å……å®ŸåŒ–
- ã‚¿ã‚°åˆ†é¡ã®è¦‹ç›´ã—
 */
export type quizManagementUpdateQuizResponse200 = {
  data: QuizWithSolution
  status: 200
}

export type quizManagementUpdateQuizResponseDefault = {
  data: QuizManagementUpdateQuizDefault
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type quizManagementUpdateQuizResponseComposite = quizManagementUpdateQuizResponse200 | quizManagementUpdateQuizResponseDefault;
    
export type quizManagementUpdateQuizResponse = quizManagementUpdateQuizResponseComposite & {
  headers: Headers;
}

export const getQuizManagementUpdateQuizUrl = (id: QuizId,) => {


  

  return `/api/quiz/v1/manage/quizzes/${id}`
}

export const quizManagementUpdateQuiz = async (id: QuizId,
    updateQuizRequest: UpdateQuizRequest, options?: RequestInit): Promise<quizManagementUpdateQuizResponse> => {
  
  const res = await fetch(getQuizManagementUpdateQuizUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateQuizRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: quizManagementUpdateQuizResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as quizManagementUpdateQuizResponse
}



/**
 * ã‚¯ã‚¤ã‚ºå‰Šé™¤API

## æ©Ÿèƒ½
- **è«–ç†å‰Šé™¤**: ãƒ‡ãƒ¼ã‚¿ã¯ä¿æŒã—ã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å‰Šé™¤æ¸ˆã¿ã«å¤‰æ›´
- **æ¨©é™åˆ¶å¾¡**: ä½œæˆè€…ã¾ãŸã¯ç®¡ç†è€…ã®ã¿å‰Šé™¤å¯èƒ½
- **é–¢é€£ãƒ‡ãƒ¼ã‚¿ä¿è­·**: å›ç­”å±¥æ­´ã‚„çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã¯ä¿æŒ

## å‰Šé™¤æ¡ä»¶
- **ä½œæˆè€…æ¨©é™**: è‡ªèº«ãŒä½œæˆã—ãŸã‚¯ã‚¤ã‚ºã®å‰Šé™¤
- **ç®¡ç†è€…æ¨©é™**: å…¨ã¦ã®ã‚¯ã‚¤ã‚ºã®å‰Šé™¤ï¼ˆè¦ç´„é•åç­‰ï¼‰
- **æ‰¿èªçŠ¶æ…‹**: å…¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ã‚¯ã‚¤ã‚ºãŒå‰Šé™¤å¯¾è±¡

## å‰Šé™¤ã®å½±éŸ¿
- **å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³**: é€²è¡Œä¸­ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯ç¶™ç¶šå¯èƒ½
- **çµ±è¨ˆãƒ‡ãƒ¼ã‚¿**: éå»ã®å›ç­”å±¥æ­´ã¯ä¿æŒ
- **ãƒ‡ãƒƒã‚­**: å«ã¾ã‚Œã‚‹ãƒ‡ãƒƒã‚­ã‹ã‚‰ã¯è‡ªå‹•é™¤å¤–

## å‰Šé™¤å¾Œã®çŠ¶æ…‹
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã¯ç‰©ç†å‰Šé™¤ã•ã‚Œãªã„
- æ¤œç´¢çµæœã«ã¯è¡¨ç¤ºã•ã‚Œãªã„
- ä½œæˆè€…çµ±è¨ˆã‹ã‚‰ã¯é™¤å¤–ã•ã‚Œã‚‹

## ä½¿ç”¨å ´é¢
- ä¸é©åˆ‡ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®é™¤å»
- ä½œæˆè€…ã«ã‚ˆã‚‹è‡ªä¸»å‰Šé™¤
- é‡è¤‡å•é¡Œã®æ•´ç†
 */
export type quizManagementDeleteQuizResponse204 = {
  data: null
  status: 204
}

export type quizManagementDeleteQuizResponseDefault = {
  data: QuizManagementDeleteQuizDefault
  status: Exclude<HTTPStatusCodes, 204>
}
    
export type quizManagementDeleteQuizResponseComposite = quizManagementDeleteQuizResponse204 | quizManagementDeleteQuizResponseDefault;
    
export type quizManagementDeleteQuizResponse = quizManagementDeleteQuizResponseComposite & {
  headers: Headers;
}

export const getQuizManagementDeleteQuizUrl = (id: QuizId,) => {


  

  return `/api/quiz/v1/manage/quizzes/${id}`
}

export const quizManagementDeleteQuiz = async (id: QuizId, options?: RequestInit): Promise<quizManagementDeleteQuizResponse> => {
  
  const res = await fetch(getQuizManagementDeleteQuizUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: quizManagementDeleteQuizResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as quizManagementDeleteQuizResponse
}



/**
 * é«˜åº¦ãªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã€ã‚½ãƒ¼ãƒˆã€ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã‚’æŒã¤ã‚¯ã‚¤ã‚ºæ¤œç´¢API

## æ©Ÿèƒ½
- **å…¨æ–‡æ¤œç´¢**: å•é¡Œæ–‡ã€è§£èª¬ã€ã‚¿ã‚°å…¨ä½“ã§ã®æ¨ªæ–­æ¤œç´¢
- **é«˜åº¦ãªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°**: é›£æ˜“åº¦ã€å›ç­”ã‚¿ã‚¤ãƒ—ã€ä½œæˆè€…ã€æ—¥ä»˜ãªã©ã«ã‚ˆã‚‹çµã‚Šè¾¼ã¿  
- **ã‚¹ãƒãƒ¼ãƒˆã‚¿ã‚°å‡¦ç†**: è‚¯å®šãƒ»å¦å®šä¸¡æ–¹ã®ã‚¿ã‚°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¯¾å¿œ
- **æŸ”è»Ÿãªã‚½ãƒ¼ãƒˆ**: è¤‡æ•°ã‚½ãƒ¼ãƒˆé …ç›®ã§ã®æ˜‡é †ãƒ»é™é †æŒ‡å®š
- **ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³**: åŠ¹ç‡çš„ãªã‚ªãƒ•ã‚»ãƒƒãƒˆãƒ™ãƒ¼ã‚¹ãƒšãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªãƒšãƒ¼ã‚¸ã‚µã‚¤ã‚ºï¼‰

## ç‰¹æ®Šæ§‹æ–‡
- **æ–¹å‘ä»˜ãã‚½ãƒ¼ãƒˆ**: é™é †æŒ‡å®šã¯`-`ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ä½¿ç”¨ï¼ˆä¾‹ï¼š`sort=-created_date`ã§æœ€æ–°é †ï¼‰
- **ã‚¿ã‚°é™¤å¤–**: é™¤å¤–æŒ‡å®šã¯`~`ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ä½¿ç”¨ï¼ˆä¾‹ï¼š`tags=~beginner`ã§åˆå¿ƒè€…ãƒ¬ãƒ™ãƒ«é™¤å¤–ï¼‰  
- **è¤‡åˆã‚¿ã‚°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼**: è‚¯å®šãƒ»å¦å®šã‚¿ã‚°ã®çµ„ã¿åˆã‚ã›å¯èƒ½ï¼ˆä¾‹ï¼š`tags=javascript&tags=~beginner`ï¼‰

## ä½¿ç”¨ä¾‹
- åŸºæœ¬æ¤œç´¢: `?q=JavaScript`
- é«˜åº¦ãªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°: `?q=é…åˆ—&tags=javascript&difficulty=intermediate&sort=-created_date`
- ã‚«ãƒ†ã‚´ãƒªé™¤å¤–: `?tags=programming&tags=~tutorial&min_correct_rate=0.8`
- IDé™¤å¤–: `?q=React&exclude_ids=quiz-id-1&exclude_ids=quiz-id-2`ï¼ˆç‰¹å®šã®ã‚¯ã‚¤ã‚ºã‚’é™¤å¤–ã—ãŸæ¤œç´¢ï¼‰
 */
export type searchSearchQuizzesResponse200 = {
  data: QuizListResponse
  status: 200
}
    
export type searchSearchQuizzesResponseComposite = searchSearchQuizzesResponse200;
    
export type searchSearchQuizzesResponse = searchSearchQuizzesResponseComposite & {
  headers: Headers;
}

export const getSearchSearchQuizzesUrl = (params?: SearchSearchQuizzesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["tags","exclude_ids"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => normalizedParams.append(key, v === null ? 'null' : v.toString()));
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/search/v1/quizzes?${stringifiedParams}` : `/api/search/v1/quizzes`
}

export const searchSearchQuizzes = async (paginationRequest: PaginationRequest,
    params?: SearchSearchQuizzesParams, options?: RequestInit): Promise<searchSearchQuizzesResponse> => {
  
  const res = await fetch(getSearchSearchQuizzesUrl(params),
  {      
    ...options,
    method: 'GET',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      paginationRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: searchSearchQuizzesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as searchSearchQuizzesResponse
}


export const getQuizManagementCreateQuizResponseMock = (overrideResponse: Partial< QuizWithSolution > = {}): QuizWithSolution => ({id: faker.string.alpha({length: {min: 10, max: 20}}), question: faker.string.alpha({length: {min: 10, max: 20}}), answerType: faker.helpers.arrayElement(Object.values(AnswerType)), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(Object.values(QuizStatus)), creatorId: faker.string.alpha({length: {min: 10, max: 20}}), createdAt: faker.string.alpha({length: {min: 10, max: 20}}), approvedAt: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), solution: faker.helpers.arrayElement([{type: faker.helpers.arrayElement(['boolean'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), value: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['free_text'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctAnswer: faker.string.alpha({length: {min: 10, max: 20}}), matchingStrategy: faker.helpers.arrayElement(Object.values(MatchingStrategy)), caseSensitive: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['single_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceId: faker.string.alpha({length: {min: 10, max: 20}}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},{type: faker.helpers.arrayElement(['multiple_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), minCorrectAnswers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},]), tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getQuizManagementListQuizzesResponseMock = (): QuizListResponse => ({...{items: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), question: faker.string.alpha({length: {min: 10, max: 20}}), answerType: faker.helpers.arrayElement(Object.values(AnswerType)), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(Object.values(QuizStatus)), creatorId: faker.string.alpha({length: {min: 10, max: 20}}), createdAt: faker.string.alpha({length: {min: 10, max: 20}}), approvedAt: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), solution: faker.helpers.arrayElement([{type: faker.helpers.arrayElement(['boolean'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), value: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['free_text'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctAnswer: faker.string.alpha({length: {min: 10, max: 20}}), matchingStrategy: faker.helpers.arrayElement(Object.values(MatchingStrategy)), caseSensitive: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['single_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceId: faker.string.alpha({length: {min: 10, max: 20}}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},{type: faker.helpers.arrayElement(['multiple_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), minCorrectAnswers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},]), tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined])})), totalCount: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), hasMore: faker.datatype.boolean(), continuationToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])},})

export const getQuizManagementGetQuizResponseMock = (overrideResponse: Partial< QuizWithSolution > = {}): QuizWithSolution => ({id: faker.string.alpha({length: {min: 10, max: 20}}), question: faker.string.alpha({length: {min: 10, max: 20}}), answerType: faker.helpers.arrayElement(Object.values(AnswerType)), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(Object.values(QuizStatus)), creatorId: faker.string.alpha({length: {min: 10, max: 20}}), createdAt: faker.string.alpha({length: {min: 10, max: 20}}), approvedAt: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), solution: faker.helpers.arrayElement([{type: faker.helpers.arrayElement(['boolean'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), value: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['free_text'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctAnswer: faker.string.alpha({length: {min: 10, max: 20}}), matchingStrategy: faker.helpers.arrayElement(Object.values(MatchingStrategy)), caseSensitive: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['single_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceId: faker.string.alpha({length: {min: 10, max: 20}}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},{type: faker.helpers.arrayElement(['multiple_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), minCorrectAnswers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},]), tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getQuizManagementUpdateQuizResponseMock = (overrideResponse: Partial< QuizWithSolution > = {}): QuizWithSolution => ({id: faker.string.alpha({length: {min: 10, max: 20}}), question: faker.string.alpha({length: {min: 10, max: 20}}), answerType: faker.helpers.arrayElement(Object.values(AnswerType)), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(Object.values(QuizStatus)), creatorId: faker.string.alpha({length: {min: 10, max: 20}}), createdAt: faker.string.alpha({length: {min: 10, max: 20}}), approvedAt: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), solution: faker.helpers.arrayElement([{type: faker.helpers.arrayElement(['boolean'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), value: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['free_text'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctAnswer: faker.string.alpha({length: {min: 10, max: 20}}), matchingStrategy: faker.helpers.arrayElement(Object.values(MatchingStrategy)), caseSensitive: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['single_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceId: faker.string.alpha({length: {min: 10, max: 20}}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},{type: faker.helpers.arrayElement(['multiple_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), minCorrectAnswers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},]), tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getSearchSearchQuizzesResponseMock = (): QuizListResponse => ({...{items: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), question: faker.string.alpha({length: {min: 10, max: 20}}), answerType: faker.helpers.arrayElement(Object.values(AnswerType)), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(Object.values(QuizStatus)), creatorId: faker.string.alpha({length: {min: 10, max: 20}}), createdAt: faker.string.alpha({length: {min: 10, max: 20}}), approvedAt: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), solution: faker.helpers.arrayElement([{type: faker.helpers.arrayElement(['boolean'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), value: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['free_text'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctAnswer: faker.string.alpha({length: {min: 10, max: 20}}), matchingStrategy: faker.helpers.arrayElement(Object.values(MatchingStrategy)), caseSensitive: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['single_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceId: faker.string.alpha({length: {min: 10, max: 20}}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},{type: faker.helpers.arrayElement(['multiple_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), minCorrectAnswers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},]), tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined])})), totalCount: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), hasMore: faker.datatype.boolean(), continuationToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])},})


export const getQuizManagementCreateQuizMockHandler = (overrideResponse?: QuizWithSolution | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<QuizWithSolution> | QuizWithSolution)) => {
  return http.post('*/api/quiz/v1/manage/quizzes', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getQuizManagementCreateQuizResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getQuizManagementListQuizzesMockHandler = (overrideResponse?: QuizListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<QuizListResponse> | QuizListResponse)) => {
  return http.get('*/api/quiz/v1/manage/quizzes', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getQuizManagementListQuizzesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getQuizManagementGetQuizMockHandler = (overrideResponse?: QuizWithSolution | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<QuizWithSolution> | QuizWithSolution)) => {
  return http.get('*/api/quiz/v1/manage/quizzes/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getQuizManagementGetQuizResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getQuizManagementUpdateQuizMockHandler = (overrideResponse?: QuizWithSolution | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<QuizWithSolution> | QuizWithSolution)) => {
  return http.put('*/api/quiz/v1/manage/quizzes/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getQuizManagementUpdateQuizResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getQuizManagementDeleteQuizMockHandler = (overrideResponse?: null | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<null> | null)) => {
  return http.delete('*/api/quiz/v1/manage/quizzes/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getSearchSearchQuizzesMockHandler = (overrideResponse?: QuizListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<QuizListResponse> | QuizListResponse)) => {
  return http.get('*/api/search/v1/quizzes', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getSearchSearchQuizzesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}
export const getTitleMock = () => [
  getQuizManagementCreateQuizMockHandler(),
  getQuizManagementListQuizzesMockHandler(),
  getQuizManagementGetQuizMockHandler(),
  getQuizManagementUpdateQuizMockHandler(),
  getQuizManagementDeleteQuizMockHandler(),
  getSearchSearchQuizzesMockHandler()
]
