/**
 * Generated by orval v7.11.2 🍺
 * Do not edit manually.
 * (title)
 * OpenAPI spec version: 0.0.0
 */
import type {
  CreateQuizRequest,
  NotFoundError,
  PaginationRequest,
  QuizId,
  QuizManagementCreateQuizDefault,
  QuizManagementDeleteQuizDefault,
  QuizManagementListQuizzesParams,
  QuizManagementUpdateQuizDefault,
  SearchSearchQuizzesParams,
  UpdateQuizRequest
} from './schemas';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';

import {
  AnswerType,
  MatchingStrategy,
  QuizStatus
} from './schemas';
import type {
  QuizListResponse,
  QuizWithSolution
} from './schemas';

export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 426 | 428 | 429 | 431 | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes = HTTPStatusCode1xx | HTTPStatusCode2xx | HTTPStatusCode3xx | HTTPStatusCode4xx | HTTPStatusCode5xx;

/**
 * 新しいクイズ作成API

## 機能
- **多様な問題形式対応**: 真偽値、自由記述、単択、複数選択の4形式をサポート
- **自動バリデーション**: 問題文・解答・選択肢の妥当性を自動検証
- **承認待ち状態**: 作成されたクイズは承認待ち状態で管理者レビューを経て公開
- **タグ分類**: 学習分野・難易度別のタグ付けが可能

## 制限事項
- 問題文は最大500文字
- 解説は最大1000文字
- タグは最大10個まで
- 1日あたりの作成上限：50問（レート制限）

## 作成フロー
1. リクエスト送信
2. バリデーション実行
3. pending_approval状態でデータベースに保存
4. 管理者による承認待ちキューに追加

## 使用例
- 教育コンテンツの作成
- 自習用問題集の構築
- スキルチェック問題の準備
 */
export type quizManagementCreateQuizResponse200 = {
  data: QuizWithSolution
  status: 200
}

export type quizManagementCreateQuizResponseDefault = {
  data: QuizManagementCreateQuizDefault
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type quizManagementCreateQuizResponseComposite = quizManagementCreateQuizResponse200 | quizManagementCreateQuizResponseDefault;
    
export type quizManagementCreateQuizResponse = quizManagementCreateQuizResponseComposite & {
  headers: Headers;
}

export const getQuizManagementCreateQuizUrl = () => {


  

  return `/api/quiz/v1/manage/quizzes`
}

export const quizManagementCreateQuiz = async (createQuizRequest: CreateQuizRequest, options?: RequestInit): Promise<quizManagementCreateQuizResponse> => {
  
  const res = await fetch(getQuizManagementCreateQuizUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createQuizRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: quizManagementCreateQuizResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as quizManagementCreateQuizResponse
}



/**
 * クイズ一覧取得API（フィルタ・ページネーション対応）

## 機能
- **多彩なフィルタ**: ステータス・作成者・ID指定による絞り込み
- **効率的ページネーション**: オフセットベースでの分割取得
- **ソート機能**: 作成日時順（最新順）での並び替え
- **権限考慮**: ユーザー権限に応じた表示制御

## フィルタ機能
- **ステータス別**: pending_approval, approved, rejected
- **作成者別**: 特定ユーザーの作成クイズのみ表示
- **ID指定**: 複数のクイズIDを指定して一括取得

## 権限による表示制御
- **一般ユーザー**: 承認済みクイズのみ表示
- **作成者**: 自身の作成したクイズ（全ステータス）も表示
- **管理者**: 全てのクイズ（全ステータス）を表示

## ページネーション
- デフォルト: 20件/ページ
- 最大: 100件/ページ
- オフセットベース: skip/limit パターン

## レスポンス情報
- クイズ一覧（QuizWithSolution形式）
- 総件数（フィルタ適用後）
- 続きの存在フラグ
- 継続トークン（将来のカーソルベース対応用）

## 使用場面
- 管理画面でのクイズ管理
- 作成者マイページでの作品一覧
- 承認待ちキューの表示
 */
export type quizManagementListQuizzesResponse200 = {
  data: QuizListResponse
  status: 200
}
    
export type quizManagementListQuizzesResponseComposite = quizManagementListQuizzesResponse200;
    
export type quizManagementListQuizzesResponse = quizManagementListQuizzesResponseComposite & {
  headers: Headers;
}

export const getQuizManagementListQuizzesUrl = (params?: QuizManagementListQuizzesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["ids"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => normalizedParams.append(key, v === null ? 'null' : v.toString()));
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/quiz/v1/manage/quizzes?${stringifiedParams}` : `/api/quiz/v1/manage/quizzes`
}

export const quizManagementListQuizzes = async (paginationRequest: PaginationRequest,
    params?: QuizManagementListQuizzesParams, options?: RequestInit): Promise<quizManagementListQuizzesResponse> => {
  
  const res = await fetch(getQuizManagementListQuizzesUrl(params),
  {      
    ...options,
    method: 'GET',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      paginationRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: quizManagementListQuizzesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as quizManagementListQuizzesResponse
}



/**
 * クイズ詳細情報取得API

## 機能
- **完全な問題情報**: 問題文、解答、解説、タグを含む全データを取得
- **権限制御**: 作成者または管理者のみアクセス可能（承認前クイズの場合）
- **解答情報付き**: QuizWithSolution形式で解答も含めて返却

## アクセス制御
- **公開クイズ（approved）**: 全ユーザーがアクセス可能
- **承認待ちクイズ**: 作成者・管理者のみアクセス可能
- **却下クイズ**: 作成者のみアクセス可能

## レスポンス構造
- 基本クイズ情報（id、問題文、ステータス、作成日時等）
- 解答情報（問題形式に応じた Solution オブジェクト）
- 関連タグ配列
- 承認日時（承認済みの場合）

## 使用場面
- クイズ編集画面での詳細表示
- 管理画面での承認レビュー
- 作成者による内容確認
 */
export type quizManagementGetQuizResponse200 = {
  data: QuizWithSolution
  status: 200
}

export type quizManagementGetQuizResponseDefault = {
  data: NotFoundError
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type quizManagementGetQuizResponseComposite = quizManagementGetQuizResponse200 | quizManagementGetQuizResponseDefault;
    
export type quizManagementGetQuizResponse = quizManagementGetQuizResponseComposite & {
  headers: Headers;
}

export const getQuizManagementGetQuizUrl = (id: QuizId,) => {


  

  return `/api/quiz/v1/manage/quizzes/${id}`
}

export const quizManagementGetQuiz = async (id: QuizId, options?: RequestInit): Promise<quizManagementGetQuizResponse> => {
  
  const res = await fetch(getQuizManagementGetQuizUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: quizManagementGetQuizResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as quizManagementGetQuizResponse
}



/**
 * クイズ情報更新API

## 機能
- **部分更新対応**: 指定されたフィールドのみを更新
- **権限制御**: 作成者のみ更新可能
- **承認状態制限**: 承認済みクイズは更新不可
- **バリデーション**: 更新内容の妥当性を自動検証

## 更新可能フィールド
- 問題文（question）
- 解説（explanation）
- タグ（tags）

## 更新制限
- **承認済みクイズ**: 更新不可（approved状態）
- **他者作成クイズ**: 更新不可（作成者以外）
- **解答部分**: 作成後は変更不可（整合性保持のため）

## 更新後の動作
- 更新されたクイズは承認待ち状態を維持
- 管理者に再レビュー通知
- 更新履歴の記録

## 使用場面
- 誤字脱字の修正
- 解説の充実化
- タグ分類の見直し
 */
export type quizManagementUpdateQuizResponse200 = {
  data: QuizWithSolution
  status: 200
}

export type quizManagementUpdateQuizResponseDefault = {
  data: QuizManagementUpdateQuizDefault
  status: Exclude<HTTPStatusCodes, 200>
}
    
export type quizManagementUpdateQuizResponseComposite = quizManagementUpdateQuizResponse200 | quizManagementUpdateQuizResponseDefault;
    
export type quizManagementUpdateQuizResponse = quizManagementUpdateQuizResponseComposite & {
  headers: Headers;
}

export const getQuizManagementUpdateQuizUrl = (id: QuizId,) => {


  

  return `/api/quiz/v1/manage/quizzes/${id}`
}

export const quizManagementUpdateQuiz = async (id: QuizId,
    updateQuizRequest: UpdateQuizRequest, options?: RequestInit): Promise<quizManagementUpdateQuizResponse> => {
  
  const res = await fetch(getQuizManagementUpdateQuizUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateQuizRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: quizManagementUpdateQuizResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as quizManagementUpdateQuizResponse
}



/**
 * クイズ削除API

## 機能
- **論理削除**: データは保持し、ステータスを削除済みに変更
- **権限制御**: 作成者または管理者のみ削除可能
- **関連データ保護**: 回答履歴や統計データは保持

## 削除条件
- **作成者権限**: 自身が作成したクイズの削除
- **管理者権限**: 全てのクイズの削除（規約違反等）
- **承認状態**: 全ステータスのクイズが削除対象

## 削除の影響
- **学習セッション**: 進行中セッションは継続可能
- **統計データ**: 過去の回答履歴は保持
- **デッキ**: 含まれるデッキからは自動除外

## 削除後の状態
- データベースからは物理削除されない
- 検索結果には表示されない
- 作成者統計からは除外される

## 使用場面
- 不適切コンテンツの除去
- 作成者による自主削除
- 重複問題の整理
 */
export type quizManagementDeleteQuizResponse204 = {
  data: null
  status: 204
}

export type quizManagementDeleteQuizResponseDefault = {
  data: QuizManagementDeleteQuizDefault
  status: Exclude<HTTPStatusCodes, 204>
}
    
export type quizManagementDeleteQuizResponseComposite = quizManagementDeleteQuizResponse204 | quizManagementDeleteQuizResponseDefault;
    
export type quizManagementDeleteQuizResponse = quizManagementDeleteQuizResponseComposite & {
  headers: Headers;
}

export const getQuizManagementDeleteQuizUrl = (id: QuizId,) => {


  

  return `/api/quiz/v1/manage/quizzes/${id}`
}

export const quizManagementDeleteQuiz = async (id: QuizId, options?: RequestInit): Promise<quizManagementDeleteQuizResponse> => {
  
  const res = await fetch(getQuizManagementDeleteQuizUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: quizManagementDeleteQuizResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as quizManagementDeleteQuizResponse
}



/**
 * 高度なフィルタリング、ソート、ページネーション機能を持つクイズ検索API

## 機能
- **全文検索**: 問題文、解説、タグ全体での横断検索
- **高度なフィルタリング**: 難易度、回答タイプ、作成者、日付などによる絞り込み  
- **スマートタグ処理**: 肯定・否定両方のタグフィルター対応
- **柔軟なソート**: 複数ソート項目での昇順・降順指定
- **ページネーション**: 効率的なオフセットベースページング（カスタマイズ可能なページサイズ）

## 特殊構文
- **方向付きソート**: 降順指定は`-`プレフィックス使用（例：`sort=-created_date`で最新順）
- **タグ除外**: 除外指定は`~`プレフィックス使用（例：`tags=~beginner`で初心者レベル除外）  
- **複合タグフィルター**: 肯定・否定タグの組み合わせ可能（例：`tags=javascript&tags=~beginner`）

## 使用例
- 基本検索: `?q=JavaScript`
- 高度なフィルタリング: `?q=配列&tags=javascript&difficulty=intermediate&sort=-created_date`
- カテゴリ除外: `?tags=programming&tags=~tutorial&min_correct_rate=0.8`
- ID除外: `?q=React&exclude_ids=quiz-id-1&exclude_ids=quiz-id-2`（特定のクイズを除外した検索）
 */
export type searchSearchQuizzesResponse200 = {
  data: QuizListResponse
  status: 200
}
    
export type searchSearchQuizzesResponseComposite = searchSearchQuizzesResponse200;
    
export type searchSearchQuizzesResponse = searchSearchQuizzesResponseComposite & {
  headers: Headers;
}

export const getSearchSearchQuizzesUrl = (params?: SearchSearchQuizzesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["tags","exclude_ids"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => normalizedParams.append(key, v === null ? 'null' : v.toString()));
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/search/v1/quizzes?${stringifiedParams}` : `/api/search/v1/quizzes`
}

export const searchSearchQuizzes = async (paginationRequest: PaginationRequest,
    params?: SearchSearchQuizzesParams, options?: RequestInit): Promise<searchSearchQuizzesResponse> => {
  
  const res = await fetch(getSearchSearchQuizzesUrl(params),
  {      
    ...options,
    method: 'GET',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      paginationRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: searchSearchQuizzesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as searchSearchQuizzesResponse
}


export const getQuizManagementCreateQuizResponseMock = (overrideResponse: Partial< QuizWithSolution > = {}): QuizWithSolution => ({id: faker.string.alpha({length: {min: 10, max: 20}}), question: faker.string.alpha({length: {min: 10, max: 20}}), answerType: faker.helpers.arrayElement(Object.values(AnswerType)), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(Object.values(QuizStatus)), creatorId: faker.string.alpha({length: {min: 10, max: 20}}), createdAt: faker.string.alpha({length: {min: 10, max: 20}}), approvedAt: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), solution: faker.helpers.arrayElement([{type: faker.helpers.arrayElement(['boolean'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), value: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['free_text'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctAnswer: faker.string.alpha({length: {min: 10, max: 20}}), matchingStrategy: faker.helpers.arrayElement(Object.values(MatchingStrategy)), caseSensitive: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['single_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceId: faker.string.alpha({length: {min: 10, max: 20}}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},{type: faker.helpers.arrayElement(['multiple_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), minCorrectAnswers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},]), tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getQuizManagementListQuizzesResponseMock = (): QuizListResponse => ({...{items: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), question: faker.string.alpha({length: {min: 10, max: 20}}), answerType: faker.helpers.arrayElement(Object.values(AnswerType)), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(Object.values(QuizStatus)), creatorId: faker.string.alpha({length: {min: 10, max: 20}}), createdAt: faker.string.alpha({length: {min: 10, max: 20}}), approvedAt: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), solution: faker.helpers.arrayElement([{type: faker.helpers.arrayElement(['boolean'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), value: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['free_text'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctAnswer: faker.string.alpha({length: {min: 10, max: 20}}), matchingStrategy: faker.helpers.arrayElement(Object.values(MatchingStrategy)), caseSensitive: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['single_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceId: faker.string.alpha({length: {min: 10, max: 20}}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},{type: faker.helpers.arrayElement(['multiple_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), minCorrectAnswers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},]), tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined])})), totalCount: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), hasMore: faker.datatype.boolean(), continuationToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])},})

export const getQuizManagementGetQuizResponseMock = (overrideResponse: Partial< QuizWithSolution > = {}): QuizWithSolution => ({id: faker.string.alpha({length: {min: 10, max: 20}}), question: faker.string.alpha({length: {min: 10, max: 20}}), answerType: faker.helpers.arrayElement(Object.values(AnswerType)), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(Object.values(QuizStatus)), creatorId: faker.string.alpha({length: {min: 10, max: 20}}), createdAt: faker.string.alpha({length: {min: 10, max: 20}}), approvedAt: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), solution: faker.helpers.arrayElement([{type: faker.helpers.arrayElement(['boolean'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), value: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['free_text'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctAnswer: faker.string.alpha({length: {min: 10, max: 20}}), matchingStrategy: faker.helpers.arrayElement(Object.values(MatchingStrategy)), caseSensitive: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['single_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceId: faker.string.alpha({length: {min: 10, max: 20}}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},{type: faker.helpers.arrayElement(['multiple_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), minCorrectAnswers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},]), tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getQuizManagementUpdateQuizResponseMock = (overrideResponse: Partial< QuizWithSolution > = {}): QuizWithSolution => ({id: faker.string.alpha({length: {min: 10, max: 20}}), question: faker.string.alpha({length: {min: 10, max: 20}}), answerType: faker.helpers.arrayElement(Object.values(AnswerType)), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(Object.values(QuizStatus)), creatorId: faker.string.alpha({length: {min: 10, max: 20}}), createdAt: faker.string.alpha({length: {min: 10, max: 20}}), approvedAt: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), solution: faker.helpers.arrayElement([{type: faker.helpers.arrayElement(['boolean'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), value: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['free_text'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctAnswer: faker.string.alpha({length: {min: 10, max: 20}}), matchingStrategy: faker.helpers.arrayElement(Object.values(MatchingStrategy)), caseSensitive: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['single_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceId: faker.string.alpha({length: {min: 10, max: 20}}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},{type: faker.helpers.arrayElement(['multiple_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), minCorrectAnswers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},]), tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getSearchSearchQuizzesResponseMock = (): QuizListResponse => ({...{items: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), question: faker.string.alpha({length: {min: 10, max: 20}}), answerType: faker.helpers.arrayElement(Object.values(AnswerType)), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(Object.values(QuizStatus)), creatorId: faker.string.alpha({length: {min: 10, max: 20}}), createdAt: faker.string.alpha({length: {min: 10, max: 20}}), approvedAt: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), solution: faker.helpers.arrayElement([{type: faker.helpers.arrayElement(['boolean'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), value: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['free_text'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctAnswer: faker.string.alpha({length: {min: 10, max: 20}}), matchingStrategy: faker.helpers.arrayElement(Object.values(MatchingStrategy)), caseSensitive: faker.datatype.boolean()},{type: faker.helpers.arrayElement(['single_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceId: faker.string.alpha({length: {min: 10, max: 20}}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},{type: faker.helpers.arrayElement(['multiple_choice'] as const), id: faker.string.alpha({length: {min: 10, max: 20}}), correctChoiceIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), minCorrectAnswers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), choices: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), solutionId: faker.string.alpha({length: {min: 10, max: 20}}), text: faker.string.alpha({length: {min: 10, max: 20}}), orderIndex: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})}))},]), tags: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined])})), totalCount: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), hasMore: faker.datatype.boolean(), continuationToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])},})


export const getQuizManagementCreateQuizMockHandler = (overrideResponse?: QuizWithSolution | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<QuizWithSolution> | QuizWithSolution)) => {
  return http.post('*/api/quiz/v1/manage/quizzes', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getQuizManagementCreateQuizResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getQuizManagementListQuizzesMockHandler = (overrideResponse?: QuizListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<QuizListResponse> | QuizListResponse)) => {
  return http.get('*/api/quiz/v1/manage/quizzes', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getQuizManagementListQuizzesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getQuizManagementGetQuizMockHandler = (overrideResponse?: QuizWithSolution | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<QuizWithSolution> | QuizWithSolution)) => {
  return http.get('*/api/quiz/v1/manage/quizzes/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getQuizManagementGetQuizResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getQuizManagementUpdateQuizMockHandler = (overrideResponse?: QuizWithSolution | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<QuizWithSolution> | QuizWithSolution)) => {
  return http.put('*/api/quiz/v1/manage/quizzes/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getQuizManagementUpdateQuizResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getQuizManagementDeleteQuizMockHandler = (overrideResponse?: null | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<null> | null)) => {
  return http.delete('*/api/quiz/v1/manage/quizzes/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getSearchSearchQuizzesMockHandler = (overrideResponse?: QuizListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<QuizListResponse> | QuizListResponse)) => {
  return http.get('*/api/search/v1/quizzes', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getSearchSearchQuizzesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}
export const getTitleMock = () => [
  getQuizManagementCreateQuizMockHandler(),
  getQuizManagementListQuizzesMockHandler(),
  getQuizManagementGetQuizMockHandler(),
  getQuizManagementUpdateQuizMockHandler(),
  getQuizManagementDeleteQuizMockHandler(),
  getSearchSearchQuizzesMockHandler()
]
